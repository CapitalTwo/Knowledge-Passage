{"meta":{"title":"Knowledge Passages","subtitle":null,"description":null,"author":"Team","url":"https://knowledge.capitaltwo.ga","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-10-15T20:13:29.149Z","updated":"2019-06-10T07:19:44.958Z","comments":true,"path":"404.html","permalink":"https://knowledge.capitaltwo.ga/404.html","excerpt":"","text":"404 Not Found *Page not found*"},{"title":"","date":"2020-10-29T19:57:09.357Z","updated":"2020-10-29T19:57:09.357Z","comments":true,"path":"Budget/index.html","permalink":"https://knowledge.capitaltwo.ga/Budget/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-29T19:57:24.509Z","updated":"2020-10-29T19:57:24.509Z","comments":true,"path":"Loan/index.html","permalink":"https://knowledge.capitaltwo.ga/Loan/index.html","excerpt":"","text":""},{"title":"Shaokang Jiang","date":"2020-10-15T20:13:29.305Z","updated":"2020-09-23T04:09:25.593Z","comments":true,"path":"about/index.html","permalink":"https://knowledge.capitaltwo.ga/about/index.html","excerpt":"","text":"A blog system similar to wiki page for the capstone project."},{"title":"","date":"2020-10-15T20:13:29.313Z","updated":"2020-09-23T04:35:13.545Z","comments":true,"path":"android/index.html","permalink":"https://knowledge.capitaltwo.ga/android/index.html","excerpt":"","text":""},{"title":"All category","date":"2020-10-15T20:13:29.153Z","updated":"2019-06-10T07:17:25.162Z","comments":true,"path":"categories/index.html","permalink":"https://knowledge.capitaltwo.ga/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-15T20:13:29.309Z","updated":"2019-06-14T00:21:51.324Z","comments":true,"path":"css/table.css","permalink":"https://knowledge.capitaltwo.ga/css/table.css","excerpt":"","text":"table, th, td { border: none; } table { width: 100%; display: table; border-collapse: collapse; border-spacing: 0; font-family: Menlo,Monaco,courier,monospace,\"Lucida Console\",'Source Code Pro',\"Microsoft YaHei\",Helvetica,Arial,sans-serif,'Ubuntu'; } table.striped tr { border-bottom: none; } table.striped > tbody > tr:nth-child(odd) { background-color: rgba(242, 242, 242, 0.5); } table.striped > tbody > tr > td { border-radius: 0; } table.highlight1 > tbody > tr { -webkit-transition: background-color .25s ease; transition: background-color .25s ease; } table.highlight1 > tbody > tr:hover { background-color: rgba(242, 242, 242, 0.5); } table.centered thead tr th, table.centered tbody tr td { text-align: center; } tr { border-bottom: 1px solid rgba(0, 0, 0, 0.12); } td, th { padding: 15px 5px; display: table-cell; text-align: left; vertical-align: middle; border-radius: 2px; } @media only screen and (max-width: 992px) { table.responsive-table { width: 100%; border-collapse: collapse; border-spacing: 0; display: block; position: relative; /* sort out borders */ } table.responsive-table td:empty:before { content: '\\00a0'; } table.responsive-table th, table.responsive-table td { margin: 0; vertical-align: top; } table.responsive-table th { text-align: left; } table.responsive-table thead { display: block; float: left; } table.responsive-table thead tr { display: block; padding: 0 10px 0 0; } table.responsive-table thead tr th::before { content: \"\\00a0\"; } table.responsive-table tbody { display: block; width: auto; position: relative; overflow-x: auto; white-space: nowrap; } table.responsive-table tbody tr { display: inline-block; vertical-align: top; } table.responsive-table th { display: block; text-align: right; } table.responsive-table td { display: block; min-height: 1.25em; text-align: left; } table.responsive-table tr { border-bottom: none; padding: 0 10px; } table.responsive-table thead { border: 0; border-right: 1px solid rgba(0, 0, 0, 0.12); } }"},{"title":"","date":"2020-10-29T19:57:17.777Z","updated":"2020-10-29T19:57:17.777Z","comments":true,"path":"crypto/index.html","permalink":"https://knowledge.capitaltwo.ga/crypto/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-15T20:13:29.153Z","updated":"2019-04-27T04:08:33.616Z","comments":true,"path":"js/qunit.css","permalink":"https://knowledge.capitaltwo.ga/js/qunit.css","excerpt":"","text":"/** * SyntaxHighlighter * http://alexgorbatchev.com/SyntaxHighlighter * * SyntaxHighlighter is donationware. If you are using it, please donate. * http://alexgorbatchev.com/SyntaxHighlighter/donate.html * * @version * 3.0.83 (July 02 2010) * * @copyright * Copyright (C) 2004-2010 Alex Gorbatchev. * * @license * Dual licensed under the MIT and GPL licenses. */ ol#qunit-tests { font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; margin:0; padding:0; list-style-position:inside; font-size: smaller; } ol#qunit-tests li{ padding:0.4em 0.5em 0.4em 2.5em; border-bottom:1px solid #fff; font-size:small; list-style-position:inside; } ol#qunit-tests li ol{ box-shadow: inset 0px 2px 13px #999; -moz-box-shadow: inset 0px 2px 13px #999; -webkit-box-shadow: inset 0px 2px 13px #999; margin-top:0.5em; margin-left:0; padding:0.5em; background-color:#fff; border-radius:15px; -moz-border-radius: 15px; -webkit-border-radius: 15px; } ol#qunit-tests li li{ border-bottom:none; margin:0.5em; background-color:#fff; list-style-position: inside; padding:0.4em 0.5em 0.4em 0.5em; } ol#qunit-tests li li.pass{ border-left:26px solid #C6E746; background-color:#fff; color:#5E740B; } ol#qunit-tests li li.fail{ border-left:26px solid #EE5757; background-color:#fff; color:#710909; } ol#qunit-tests li.pass{ background-color:#D2E0E6; color:#528CE0; } ol#qunit-tests li.fail{ background-color:#EE5757; color:#000; } ol#qunit-tests li strong { cursor:pointer; } h1#qunit-header{ background-color:#0d3349; margin:0; padding:0.5em 0 0.5em 1em; color:#fff; font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; border-top-right-radius:15px; border-top-left-radius:15px; -moz-border-radius-topright:15px; -moz-border-radius-topleft:15px; -webkit-border-top-right-radius:15px; -webkit-border-top-left-radius:15px; text-shadow: rgba(0, 0, 0, 0.5) 4px 4px 1px; } h2#qunit-banner{ font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; height:5px; margin:0; padding:0; } h2#qunit-banner.qunit-pass{ background-color:#C6E746; } h2#qunit-banner.qunit-fail, #qunit-testrunner-toolbar { background-color:#EE5757; } #qunit-testrunner-toolbar { font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; padding:0; /*width:80%;*/ padding:0em 0 0.5em 2em; font-size: small; } h2#qunit-userAgent { font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; background-color:#2b81af; margin:0; padding:0; color:#fff; font-size: small; padding:0.5em 0 0.5em 2.5em; text-shadow: rgba(0, 0, 0, 0.5) 2px 2px 1px; } p#qunit-testresult{ font-family:\"Helvetica Neue Light\", \"HelveticaNeue-Light\", \"Helvetica Neue\", Calibri, Helvetica, Arial; margin:0; font-size: small; color:#2b81af; border-bottom-right-radius:15px; border-bottom-left-radius:15px; -moz-border-radius-bottomright:15px; -moz-border-radius-bottomleft:15px; -webkit-border-bottom-right-radius:15px; -webkit-border-bottom-left-radius:15px; background-color:#D2E0E6; padding:0.5em 0.5em 0.5em 2.5em; } strong b.fail{ color:#710909; } strong b.pass{ color:#5E740B; }"},{"title":"","date":"2020-10-15T20:13:29.145Z","updated":"2019-04-27T04:08:33.833Z","comments":true,"path":"src/shAutoloader.js","permalink":"https://knowledge.capitaltwo.ga/src/shAutoloader.js","excerpt":"","text":"/** * SyntaxHighlighter * http://alexgorbatchev.com/SyntaxHighlighter * * SyntaxHighlighter is donationware. If you are using it, please donate. * http://alexgorbatchev.com/SyntaxHighlighter/donate.html * * @version * 3.0.83 (July 02 2010) * * @copyright * Copyright (C) 2004-2010 Alex Gorbatchev. * * @license * Dual licensed under the MIT and GPL licenses. */ (function() { var sh = SyntaxHighlighter; /** * Provides functionality to dynamically load only the brushes that a needed to render the current page. * * There are two syntaxes that autoload understands. For example: * * SyntaxHighlighter.autoloader( * [ 'applescript', 'Scripts/shBrushAppleScript.js' ], * [ 'actionscript3', 'as3', 'Scripts/shBrushAS3.js' ] * ); * * or a more easily comprehendable one: * * SyntaxHighlighter.autoloader( * 'applescript Scripts/shBrushAppleScript.js', * 'actionscript3 as3 Scripts/shBrushAS3.js' * ); */ sh.autoloader = function() { var list = arguments, elements = sh.findElements(), brushes = {}, scripts = {}, all = SyntaxHighlighter.all, allCalled = false, allParams = null, i ; SyntaxHighlighter.all = function(params) { allParams = params; allCalled = true; }; function addBrush(aliases, url) { for (var i = 0; i < aliases.length; i++) brushes[aliases[i]] = url; }; function getAliases(item) { return item.pop ? item : item.split(/\\s+/) ; } // create table of aliases and script urls for (i = 0; i < list.length; i++) { var aliases = getAliases(list[i]), url = aliases.pop() ; addBrush(aliases, url); } // dynamically add tags to the document body for (i = 0; i < elements.length; i++) { var url = brushes[elements[i].params.brush]; if (!url) continue; scripts[url] = false; loadScript(url); } function loadScript(url) { var script = document.createElement('script'), done = false ; script.src = url; script.type = 'text/javascript'; script.language = 'javascript'; script.onload = script.onreadystatechange = function() { if (!done && (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) { done = true; scripts[url] = true; checkAll(); // Handle memory leak in IE script.onload = script.onreadystatechange = null; script.parentNode.removeChild(script); } }; // sync way of adding script tags to the page document.body.appendChild(script); }; function checkAll() { for(var url in scripts) if (scripts[url] == false) return; if (allCalled) SyntaxHighlighter.highlight(allParams); }; }; })();"},{"title":"All tags","date":"2020-10-15T20:13:29.137Z","updated":"2019-06-13T03:26:51.471Z","comments":true,"path":"tags/index.html","permalink":"https://knowledge.capitaltwo.ga/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-15T20:13:29.149Z","updated":"2019-04-27T04:08:33.852Z","comments":true,"path":"src/shLegacy.js","permalink":"https://knowledge.capitaltwo.ga/src/shLegacy.js","excerpt":"","text":"/** * SyntaxHighlighter * http://alexgorbatchev.com/SyntaxHighlighter * * SyntaxHighlighter is donationware. If you are using it, please donate. * http://alexgorbatchev.com/SyntaxHighlighter/donate.html * * @version * 3.0.83 (July 02 2010) * * @copyright * Copyright (C) 2004-2010 Alex Gorbatchev. * * @license * Dual licensed under the MIT and GPL licenses. */ var dp = { SyntaxHighlighter : {} }; dp.SyntaxHighlighter = { parseParams: function( input, showGutter, showControls, collapseAll, firstLine, showColumns ) { function getValue(list, name) { var regex = new XRegExp('^' + name + '\\\\[(?\\\\w+)\\\\]$', 'gi'), match = null ; for (var i = 0; i < list.length; i++) if ((match = regex.exec(list[i])) != null) return match.value; return null; }; function defaultValue(value, def) { return value != null ? value : def; }; function asString(value) { return value != null ? value.toString() : null; }; var parts = input.split(':'), brushName = parts[0], options = {}, straight = { 'true' : true } reverse = { 'true' : false }, result = null, defaults = SyntaxHighlighter.defaults ; for (var i in parts) options[parts[i]] = 'true'; showGutter = asString(defaultValue(showGutter, defaults.gutter)); showControls = asString(defaultValue(showControls, defaults.toolbar)); collapseAll = asString(defaultValue(collapseAll, defaults.collapse)); showColumns = asString(defaultValue(showColumns, defaults.ruler)); firstLine = asString(defaultValue(firstLine, defaults['first-line'])); return { brush : brushName, gutter : defaultValue(reverse[options.nogutter], showGutter), toolbar : defaultValue(reverse[options.nocontrols], showControls), collapse : defaultValue(straight[options.collapse], collapseAll), // ruler : defaultValue(straight[options.showcolumns], showColumns), 'first-line' : defaultValue(getValue(parts, 'firstline'), firstLine) }; }, HighlightAll: function( name, showGutter /* optional */, showControls /* optional */, collapseAll /* optional */, firstLine /* optional */, showColumns /* optional */ ) { function findValue() { var a = arguments; for (var i = 0; i < a.length; i++) { if (a[i] === null) continue; if (typeof(a[i]) == 'string' && a[i] != '') return a[i] + ''; if (typeof(a[i]) == 'object' && a[i].value != '') return a[i].value + ''; } return null; }; function findTagsByName(list, name, tagName) { var tags = document.getElementsByTagName(tagName); for (var i = 0; i < tags.length; i++) if (tags[i].getAttribute('name') == name) list.push(tags[i]); } var elements = [], highlighter = null, registered = {}, propertyName = 'innerHTML' ; // for some reason IE doesn't find by name, however it does see them just fine by tag name... findTagsByName(elements, name, 'pre'); findTagsByName(elements, name, 'textarea'); if (elements.length === 0) return; for (var i = 0; i < elements.length; i++) { var element = elements[i], params = findValue( element.attributes['class'], element.className, element.attributes['language'], element.language ), language = '' ; if (params === null) continue; params = dp.SyntaxHighlighter.parseParams( params, showGutter, showControls, collapseAll, firstLine, showColumns ); SyntaxHighlighter.highlight(params, element); } } };"},{"title":"","date":"2020-10-15T20:13:29.309Z","updated":"2020-09-23T04:08:27.317Z","comments":true,"path":"web/index.html","permalink":"https://knowledge.capitaltwo.ga/web/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-15T20:13:29.157Z","updated":"2019-10-27T18:47:24.609Z","comments":true,"path":"js/USA.js","permalink":"https://knowledge.capitaltwo.ga/js/USA.js","excerpt":"","text":"(function (root, factory) {if (typeof define === 'function' && define.amd) {define(['exports', 'echarts'], factory);} else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {factory(exports, require('echarts'));} else {factory({}, root.echarts);}}(this, function (exports, echarts) {var log = function (msg) {if (typeof console !== 'undefined') {console && console.error && console.error(msg);}};if (!echarts) {log('ECharts is not Loaded');return;}if (!echarts.registerMap) {log('ECharts Map is not loaded');return;}echarts.registerMap('USA', {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"id\":\"01\",\"properties\":{\"name\":\"Alabama\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ไaƨܡȸ੝ĬɻĠƅĉĬ¹ƛŁLŁóƛĊʩÑəĠɯбKᄑ@ōȌǇƏÜçŭůŗɃƐwȸÝxýƻƱɍ¤Ý౺ȘུŢऄēĔ܀L\"],\"encodeOffsets\":[[-89455,35842]]}},{\"type\":\"Feature\",\"id\":\"02\",\"properties\":{\"name\":\"Alaska\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ƒǴĉƛɏlè\"],[\"@@ƾĵēƥéº@Ȣ\"],[\"@@ȮlĖŭǵǇþþĖ\"],[\"@@ζĠǉζǳŮōXğĔmbšƦţnŁĬ¤ĉl͛ÏóɻbÝǔĉaǝŮ»£ƛ¤xŭƆĔ¯£ǝǉlʑɐçŌbŘȗU@ĖƨVƦþÛƒǩɚÛŎţý¯ŮŮÒĵƜÒ\"],[\"@@ǈÅŎèŌŗůǵēł\"],[\"@@ţĊƐÆҘýȬJƜƻˀŻĩƏ»ȋxƅÑǿȭ£ȢlźƱLô\"],[\"@@ŗÜůƒałĸºł¹xĔͨƱƥŗmóǓĊ¯ķȕŹ¤kţĉÒ»ɼƨŎ\"],[\"@@īŗÆ̹ώȡŌèĖÿɄəǞɦǔĶçȤÅǴULƅǪѩ@ϋ\"],[\"@@˸ÛǔVUÝʈɯǓ¥ýǶţÆɃǵÇÏñ̃ƱēJǊÒĪƜĵǪlĠÛɦōĬǔȬƽ\"],[\"@@Ť@ŰƱÇŁȋwǔŘ\"],[\"@@ʪIǔôʆķŹŋ²¥ŢŰ̄¥ǈğğǓôaĪəəХǴbǿŹóƱġŘǩþƃǈǟôVƆŚ°ŘĈ»\"],[\"@@ΟɃĉ˵ÅÐź̰ƄȘƨłÑ\"],[\"@@¯ǩţǵǓÒƒȸȖĖ\"],[\"@@ĖѪɰx͆@ΊȬlȤçΪýӚmƆ°͐ƐÒΖVK£ȸxєÝ̂Ł˖»Ò¯ʞUɼý°»Ɯ¦Ǫ@䫿ϺçºôШŁʒƆԜbğɥźÿ̄ñÜţࡦѵƆ˫ƲĀςƄȸLĬĶUƲƦ@ƆˀϸŘϤȡšĠţɐ˖ǵm¹ŰīΈō֘әĊŹǪŹʶ˵ʴʓīĵˊÛƥɎÑǟɎVвǩʴƆĉźwĉ˖wĊĵůȋnƽŤʳġÝȫɻ̍ǝĉĔōýǪxôğĔȖĠÅȗřŁôţ£ΓȀŤȮəçUķǩĀĪŢłłǓēǓȌķÛƾǈĶƾ@¯ŮĊǊŹKˋƐȉǔѵŤVͲƛ¦ƐƧɍȀÑĬύХʞǩ׆ĉƅţǔɯ£ŌȋwŭǇŹƒǟxʅJȢƥǔƅ»ՉǪ¯¹̂ÇɦƏĖIōŚŹ̃óǝ°KŗəĖóÜƏ@ϣǔ˫ƦĖƽźѝĠʇĬлŎˡłxŘĀĠôğǔŘĠÅ¤ȹǩѝŗԧ¤ѝłmĊȫkɏÒәÆ˫Lؿ¯ɥ˷ŤΟÈŋò¥ŰʑWĉŋѝƦçÞѿţɏƛğƆĠôźmшĬÅôȡÿĬǿ`ǿʔéÑʳĉēÿ͑aĕɍwķôƼğIƥǓȬÅnţŮŹóƑǇ°¯çƾĔȁɣůȡ¹ĵ¤ʿIVèŭ¯çĕōþƏŋÒ»ȗÛǩWçēȋÿŹƛğŗLʇȋʳaĉÒƽķ͏ĀôƜɄºƐU¤ÆʞŎVĠ͛ŭ˕ò¼ƐɄɼƲŰèxƄţƨ̂ÆւɄƆĉǠwʨĖ˫ŘōĔəUƽ¦¯ʽÑţŗʿ˕ƅēȹ¯¯īƥÑçǟ˷ŋƐĕŗŹˉwwǓʝÑÿêŭŻƧIğ͛ÇÝʧώa̎çĊĉţƅȡĉȁIkóţÆğŭƏˉŹƱ@Ƨ¯ƛVŋ»çȹ£ĵƛÞƽȣʽblŁƻō¯@ƛǩə˫ɱĵÇƥĀʝɃçÒƏmţƙ¯ǟnƅţɼʧˉܫĕȭɻ»¼ƦƛxǳÅÑ˫īţŋþóğǓÒ̭ƛɱLŌĵłğēVğ̯˭ŁêŁɃlǔŹ¯ÑŘóÅŗǟÑŹźƽV¹Ƽó˵ţȖLÇǇ¦ɏōлLȹókÅʇÝǩxÑƾǪ¼ƆȌǪJϘṲ̋JŘšĖĔmĸǬ°Ȍ@ʨɚˬȢςǪўþǶǪº°ñīĉłÝĶɐXÒÝƆwJþəêm°ƨɎȢŰˊŢшł̰ƴƨÇŢx¹ĬĠɼȘ͐ŮʴǔaĠȺٺ͐ǪƐޝȡʑxÑĊƏ¯Ġů¥ýƙƆǵǉýƙˡ˸ȋƜī@ÛŁĉmůĖƱbçƜ҉ǉЛŗÛͅīƽĔƜĸ»ʆŁʪɄłǩɄƱŤţǪǳò¯ƱɏΉīЯ£ɥVȗ¼wƄǓ¦ʽȀɛʳȮǪĠǠƃmłÞĔǟĀkĉȹƜǉlēĬJŤǇÇŚȢǉź˸X@ƼèłՊʹŎĶþk¯ƚȮʔǪĬ͜¤ʪ£ΞƧɲl͆Ɯ͜ɐǔx¤ÅІ@Δ°̺ɦ@ÆƻɄmŮʑƆğŘʞɼĬbĠ̥ǞɣƃɃxȣóɣkÇ»ʳóýŭŹ»ÑƦƽŋŗÝǼĊקKчğǇaΉÆٷÞǝ¼ÿĊÒŘɻĬ°łƨÆ¯Ɔɻ@ȗϗȡẹ̀èĖӄŘײȘмŘʈÝʒ_ÆĠƥbaþאźڄĬΠVȘķƑĩñéŮŋɰl̄kͲxĬ¥ɚUȘ¦ʨ¯ʒȀǪVŤÒłͱ¼͑£ƐʧƦ˟°ĉƆɎˢƃ»ŁƆĉ̂īèĶͧƆƜʈŗ¤͛»ͳb¹¦ǟ¥۳ĸaŀɃɾǝĔ˕ôցȮʩþʧlϗƒρþkˠ¤ŰźVʴݚkࣖÒɼ°όźΠȢôȢƲǠ̺ƚƆłϮǠÒ¯͐aҸĖ̎Ġ۴˸ˌ`£˖ˌUԾԨŮԞʴȸÈ±޾ŁÜñ˓īůKLŹЄ¦xèǶÜÒƄƦϺƅÛĵʒƜÑɄĬόLɄլˠƃȡԐ»»ӰēL¤ΠÈ;KL¯ȢKȸÞ;Vʈ͜çƲbɐīŮȮƦÑ\"],[\"@@K́ÈȸɎȌnźȢƜǩŤÒɰī@ƅͱkƧÑʅ\"],[\"@@ʆŎɍxKĬǶÜź¯līôÞLƜƼÝĠƐÅǔ@ź¼Ʉĕ@ʑˊlǩǇ͏ÞŢŁğĕǓ¤IǑʩ¯ĉéƻÞǓǩŹmƏý»ȌȗĵUÐǩÒaǠǝèĪȢʹŰȸWnğ\"],[\"@@ǩǝÇɲƜ\"],[\"@@ƆU¯ǫəxÒǞĸ\"],[\"@@»ǵʳƧŮɦĖwĬŰ\"],[\"@@Ƽ@IğƽĵƏèĕÝ¹ƾ°¼ɼm\"],[\"@@lóĩ¯óĀƲ¤\"],[\"@@ŭĉ¥ôǔV\"],[\"@@ǶmçƛLkĪ\"],[\"@@ÒīŹ£¯ĶŘ\"],[\"@@ʳğÅÞŌĊȮÇ\"],[\"@@Ȗ¦ÑǞbǔÇʅēÿɏ¯¯ĉͅĢƥKͅŤō@ǿèÝŎĠ̼ƦĔƾVèÒŎ\"],[\"@@ƒÛ˫ƽJΠŘLÝƛýɱ»wýʝĉɍKƛýˉçƛôˬĔĔaɄô¹ĊŤĖǴ¥nÆȗnŁÒĠĶ͞ÒèŗƼŌ\"],[\"@@͒ǈlèŰþȖĶ£ōΩţȗǩƻÑĕǊ\"],[\"@@ĉɍIwÆȮ\"],[\"@@ŗýwþƐ@\"],[\"@@ÈýƽÅwĊŮº\"],[\"@@ښŭϮłǬUƼÑ¦ĵͲÇł¹ѪwˀƛůɃɥwŗÅŁůǉŘȉĀǫVĉĔхŎȣḶīɯ¼īĶĠȖ\"],[\"@@`ĩǇmĊŚ\"],[\"@@Ō̼Jbύ¥Ûĸ\"],[\"@@KĊŤǞĉÛýķLĕǉUͽğȕÆÞȺUˬƦ\"],[\"@@Ʋb@Łȕ`ʇŭğǔĶJbŰŮJ@ğƆI\"],[\"@@Ġ£ÛƛŹ¥KĖłƐ\"],[\"@@ƜKźĵƏţƅɦ\"],[\"@@ƼÅXĕͳ¹əƐ@ÜϺU\"]],\"encodeOffsets\":[[[-134760,56441]],[[-134996,56755]],[[-136168,57793]],[[-136801,57703]],[[-136947,56890]],[[-137121,58298]],[[-137334,57838]],[[-137867,57636]],[[-137946,59621]],[[-139118,58707]],[[-139550,59604]],[[-150609,61646]],[[-151103,62033]],[[-151333,71932]],[[-156610,59419]],[[-157653,58920]],[[-158242,57961]],[[-159370,57266]],[[-163727,56610]],[[-164372,56688]],[[-166150,56301]],[[-166313,65162]],[[-166711,55796]],[[-169521,55600]],[[-169717,55454]],[[-170356,61809]],[[-170368,55308]],[[-172841,54434]],[[-173822,54164]],[[-174232,58595]],[[-174765,53962]],[[-175864,65246]],[[-176570,53648]],[[-177793,53402]],[[-178505,53536]],[[-180704,53099]],[[-181405,53194]],[[-182398,53166]],[[-191377,54265]]]}},{\"type\":\"Feature\",\"id\":\"04\",\"properties\":{\"name\":\"Arizona\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@K⶙ၵ@ট̺ᓋڐþȌǔ°ô¯ƾŗJÇ̼ǠŢxŰȢĶƨƆÆĶŌǓŤŗɚƏƒ@ł¼Řmƾçǈ»Ӱ̰ĶĵĊJĖƜ@ڲᲤJ௨I\"],\"encodeOffsets\":[[-111659,37889]]}},{\"type\":\"Feature\",\"id\":\"05\",\"properties\":{\"name\":\"Arkansas\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@⋒IôǇŹķƅƽլ@ƻŭ¯ŹƻƑbȫĉƧĉwºóƃÛÑƛĕbǓƱ¯LÅǫƏ¼ġƱƃƅʳƨōóç°ǩÛŗᏋ`ε@@ҀšǓ£ĕþ°๒ƽघŤ@\"],\"encodeOffsets\":[[-96741,37378]]}},{\"type\":\"Feature\",\"id\":\"06\",\"properties\":{\"name\":\"California\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ܖJૼ_࢈@JนI੝ઌݯ৺ݍߪ׽׆ѿ৺߿@ŁƐƑŘəǔţĵŋƅÅĵƧȡwůǟšÈ̻ŘI°ƽ¯óǓ૙ý࣡óĵŎKǪÝȸšƦʿȮͱȌÝ¹ŹlĊƥǞȡΓŰ»ĶɻŰˉKɛÆ˫wƥŎɼ»ǔɛŮUǠĉVƏƦī£Ġ͑ΈƱĸ˖ÜwÒǈţƦƥkȗƆçłbĶīƆ@ɚƾ@Ṵ̂é_ƱǓȣŘȢŹƾǝĬğŌʝɐ¤Üŗˮ¼ƼóɼɏɲɃź£ƲɄς¤Ů£ĬþʨçɲğÆȀ࠘L\"],\"encodeOffsets\":[[-126190,43015]]}},{\"type\":\"Feature\",\"id\":\"08\",\"properties\":{\"name\":\"Colorado\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ᇆIඨJှ@@ࡃVᡍߩL૯Kᑽ@ҭLഷ@@ঔaĢL܊J༼ैJ\"],\"encodeOffsets\":[[-110509,41988]]}},{\"type\":\"Feature\",\"id\":\"09\",\"properties\":{\"name\":\"Connecticut\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ੈ_@a@ӻ»ýñbρÝѩnȋřȭʅĩÑĪȸĢÑèÈٌζW\"],\"encodeOffsets\":[[-74806,43048]]}},{\"type\":\"Feature\",\"id\":\"10\",\"properties\":{\"name\":\"Delaware\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ýĵēÅlƅŮŭȹǴɍĊW́իVý੔ƜĠǞw\"],\"encodeOffsets\":[[-77224,40760]]}},{\"type\":\"Feature\",\"id\":\"11\",\"properties\":{\"name\":\"District of Columbia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@łĉŋēÝŤèº\"],\"encodeOffsets\":[[-78884,39930]]}},{\"type\":\"Feature\",\"id\":\"12\",\"properties\":{\"name\":\"Florida\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@вLŘʓ଴ÅંÛ¤ǵĸJǠƾĀÜȖçɲºεłХʔաόֹÅ£lˉƾ̙ʒ׽¼ȋKȕğ۝ÿaćɍéǇƻÝƻÝˋýĖźȋόƥèŻ»ĵȺǞǩȌ£ŰǴĩxŁĕˉҖŁŚʨͲǓkŋŁōǒƨҢϤĵĠŮǉȉȮƳĊUŮŁ°ēƐ͑Ȃ˫¥bŹğxΕƻϋVĠēŎѩʜ̹ł˭ɻkԛÿŮŰÛèƐȋǈŎᄒ@\"],\"encodeOffsets\":[[-87549,31742]]}},{\"type\":\"Feature\",\"id\":\"13\",\"properties\":{\"name\":\"Georgia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ǵǵaĕˬǳĖbźȁīƆǩȘŁŌƻɦƛUīƦƽɦŹÆƏXǵŘÑƆɣJƛȘóȹ˷ƥēŹUƅğÑΩɱȕèÿÛƽǟķI£ǶઁÜଳÆŗʔğɰÒɚĉʪôƜKłƜłīºĊğƆīɼȷਫ਼ƧܢઌJלIєb\"],\"encodeOffsets\":[[-85103,35842]]}},{\"type\":\"Feature\",\"id\":\"15\",\"properties\":{\"name\":\"Hawaii\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ȷòôȌƥ͒ŘłĊƦÑĬnĶɼţʾēǊŹ@ōʆǵƥƥʿçǿōķƻ\"],[\"@@ĪŗŰº˖ƃ¥ţ˟ÑÇx_ƦƛÇĊĢĠ\"],[\"@@ĉĕȗ@ÒĬɐU\"],[\"@@Ġȡ¯ŗǵmšɼłLƦĠ\"],[\"@@ĪU°ĕŭīÿˉĬƐɐÞ\"]],\"encodeOffsets\":[[[-159370,19404]],[[-160345,21535]],[[-160749,21720]],[[-161742,22219]],[[-163295,22763]]]}},{\"type\":\"Feature\",\"id\":\"16\",\"properties\":{\"name\":\"Idaho\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@@ࡱ˖ɻJɯǊķǞnÑ̺ɣġɚēVÅʒJš̹wȡĔŹƱġÒē£ğǴĕȺŘĊĠƲćwéĊǇƐǝĶÑIǉĪçǬUŌ˕Ĭ¯ĔþˀIȘôŘ¥Ȣ¦¯ǞȘǪƄƥƲĕ@ᐍयIཅ@ᠡJ@໢ŎˢéèǇbÑŘǠ̚ĔĖŰaþĬĶºƨǬʞéŘȡÒŗƜIƦōƨbèK૰Vਨࠤ@\"],\"encodeOffsets\":[[-118832,50177]]}},{\"type\":\"Feature\",\"id\":\"17\",\"properties\":{\"name\":\"Illinois\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@༐aࠢ@ǇźȋƄ̯IጡğƱłǵ`ƧŁšōƱǵī_xŁÝ¥¹ȡÅŋţþƧΉýĕĀŋŁç̯źīWŹƥ¤¯ƃVȋʈèÆçǈ@ź˕ǶğkğŌʝǠJƄƜɐwþĊĸţÒǿīÿÛ¼Çˠ˫ǶʳɐŁʴUǞôŤbƲɼĠxźŌĊbƨƏŤÆƦ͜¦ˀłźŌÆǈyłȉĊyĖǿƲ\"],\"encodeOffsets\":[[-92815,43531]]}},{\"type\":\"Feature\",\"id\":\"18\",\"properties\":{\"name\":\"Indiana\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@শ@@ÅLোa୭ÝèɱƥKƽýɍVǓƛçÅŁƧ£ýɃīÇȋĀĪǿŁ`ğȉÇĊɃĉçĕɃŰŋóÒçÑɃUÿýÆºȢÞ¦włĬ`ƲǶŎłŢ_ƨŁǶĠƲJጢĊÅʴ@ʞĪ۪@\"],\"encodeOffsets\":[[-88053,42762]]}},{\"type\":\"Feature\",\"id\":\"19\",\"properties\":{\"name\":\"Iowa\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ź@VůŰćĵķȋÞƃ̘īÒŁȀƱzĕȊĉzŁǇŋÅŹʿŁ͛¥ÅƥƐţaƧŋĉwŹɻğaƱğǟǞēI஥wଽW॑bīŎ°ɎĉȌLɄƧôwŘ¼ĸÅƦřÆƱϘƻȂòŮǔÜÒŁĊƦ¯èŎn⣨@\"],\"encodeOffsets\":[[-93561,44546]]}},{\"type\":\"Feature\",\"id\":\"20\",\"properties\":{\"name\":\"Kansas\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@㔌@Ċý˖ÝȋʑłĉƄȡǶ¥KᆁⰃ@࿥KUᡎŰ@\"],\"encodeOffsets\":[[-104351,40962]]}},{\"type\":\"Feature\",\"id\":\"21\",\"properties\":{\"name\":\"Kentucky\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ȌŗƆÒ͆ÝĠĊŤƛĬwŘŗwʩĶǇƆŭ¤īǊīŌa͏ɣ̯ů@ÛůÇUñǇÅğҋţa_ܕVسǓUङ੓kȁbƱ਱VĵU°łŮè;£°źƦĬX̰ŹłèÿŌĖΊþýƨŌŤĀþɄVèÒôÑŌɄůèĖɄĊÈĉȊ_ĠȀłĩȌÿĬÈþɄƨ¤ÆłƜèUǔɎƾþƦLçɲÞ͐@Ǡǩbñʾ\"],\"encodeOffsets\":[[-85917,39700]]}},{\"type\":\"Feature\",\"id\":\"22\",\"properties\":{\"name\":\"Louisiana\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Ꮜ_þīÑUǟŮĿnʝķȗȡţ¹ȋĉna̯ķUÒǓÑÑཞ@ĉˡƒǿƏĶĕʝŗkĉȮÅĔƆǪƅ_Łķ¯ȋ¤xýÛţǈŁʴĠůôkƅƛƥŭƦ̯Ā@ƚƱ¯VšçōōkĉŮȕLçŹŹƑþŋVŁȺȋĠóaóǪəwKłɍĵÿǓñʳ̙ŚɃºҕ£ÑóĊȢ̘ÛǈÒĖŘĊĖĖɎaǶɱ;IȀȁȂ@ࡰζ@\"],\"encodeOffsets\":[[-95855,33811]]}},{\"type\":\"Feature\",\"id\":\"23\",\"properties\":{\"name\":\"Maine\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ķÒbĊƅĪÅૄ£լζŘÑÒƐźƜÒ¼Ɔþ¥ƨĊɚźô¼ɼٮ٢ƲVƽŎÅ˖ĠǞ@ŤÒɼƃƐōXऻmɥ̂Ï£īôğÑĉŤŹƼƲ̗ǩƅĵ¼ĉğţxaÿƻXʝǵÑŮĕV¦ƃȗÝ¯łğÅɏ@IŮŹxĕţǿx»ƽĵƻġŁŹaŁĕŹnĠȋƧºğƏUýƽīŭə\"],\"encodeOffsets\":[[-72400,44092]]}},{\"type\":\"Feature\",\"id\":\"24\",\"properties\":{\"name\":\"Maryland\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@k@w@¤@\"],[\"@@᷈@þ੓լUǓΟŹaɯ¹ǵLƐçÆĪÒŹƐ£Ïǩ`ÑƲÆ@LȤÆþóˊĢƾƚxǈŁmIćəŁÝīaʓĉŗȕŎƅaĵèķçȕƆˡÜĉźƻñÑĶŮźôƆŌĔŁĊç¹ŋþǩ¤@ŰġèŹbĩɼƛ@ƛþýÛƑJğʝÒǓŭŋǓƛǓýVў\"]],\"encodeOffsets\":[[[-77818,38865]],[[-81385,40676]]]}},{\"type\":\"Feature\",\"id\":\"25\",\"properties\":{\"name\":\"Massachusetts\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ĊaƧšƃōKŹȀkŎƅkŁĠVĩɼĉ˖þÑŗЏķƥIĕþƏwKÑƽÛƲwĕÒ¯Ȣŭ@ɥU@bੇ`εXmȮւڼaঊĠĀɦĊ\"],\"encodeOffsets\":[[-72619,43918]]}},{\"type\":\"Feature\",\"id\":\"26\",\"properties\":{\"name\":\"Michigan\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@଑@Æ঵@۩@ǠŎŘȌłŘþǊ°ɰkʞʝӤþȂÅɚȘɦ¤ȌĶƒ¤lƒɐǔƲḁĔ_ŎƲLʴèÜɰ¦óǶƲƲȌVɄīȺaĶţƾUˀŋĠJƜǵřĩŎů¤ƛ¹̹ǟý£ǉȭÅōȕ¦óȮçƼłȂɎ̂ĊƜÛĔţĖΓbǩĠɃĕ̥Ə¯IŎġŁʩǝī»ȕɃǇaé\"],[\"@@bķōk²Ɯºw\"],[\"@@ŹĖþŢȡnĀŘVƦǩĸīłΫĊŋΫŰࡻǞğƜƽ¼͜Ĕƨĸπ¤ʈŮŎLĠĖˀŮƄłȢèȌÑͧʳýēLƽǈŤ̂mɦĉȮɯŎ¥Ʉº¹ɄҌȘɼl̺UɄÜǈLɻǔǔèÅŌèʔxJ̍ŎŭǔlĊǈ@ĖĕóÛҡÆəʅĶéğýŁlƽŚ˕èƏJƅŋəʇxĩ¯wğʿÿbŎřx¯ŗȕKĕ¹Źȣʅʧlw\"],[\"@@ɃŁōaXĖՊȢķƏŗ\"]],\"encodeOffsets\":[[[-85457,42734]],[[-87560,46829]],[[-89691,46178]],[[-90936,49128]]]}},{\"type\":\"Feature\",\"id\":\"27\",\"properties\":{\"name\":\"Minnesota\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Ûǟç@ӻ¹»ʇçȕǵašĪWłŁĩŹlƛṊ̃ɚƱǬaĔğʴġ¦ŋʆƛƆǈȁwƃ°īŹ@⣧@@ພȗĬƥǊɰǴlĬͲĵĖçȀbɦՠǓ˸Ýǈ;ÆŘōˌნ@@͐ǔUŌÛŎѩĖ»ˠa£͒mğˠx@ɐ°ȌkɎçÒĕŰVŘȋÆĀɄÿʞÅ@óŮÑʪƲĈȸ¼ôŭƜǞȤlɤŁɐnm¯˫ŁϷĉʩĕεɏƽƃʅƱϗȭÜç\"],\"encodeOffsets\":[[-94223,47827]]}},{\"type\":\"Feature\",\"id\":\"28\",\"properties\":{\"name\":\"Mississippi\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ɦ@ĔēšःȗཱིÞ౹ġȫnĉÆȭ˫īĕÑĵĖƐƑȀĊˢཝ@ÒÒÑǔĸVb̰ĊmºȌȢŤĸȘmʞŭŀVǠÒýĬÜŘ¯ǪôèƧŎƆʴƲƄ»ĢǬƐKÆƲ°aǔĖÒƜƄÜ¹ô໸@\"],\"encodeOffsets\":[[-90594,35836]]}},{\"type\":\"Feature\",\"id\":\"29\",\"properties\":{\"name\":\"Missouri\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ĔJǠǝĠóţVǝłʳʴɏˬǵÈ˟Ü»ĬĀȀŤÑĉķxýƛɏIƃʞǟĠŋĠl˖ǵ@ŹèǇçÅȌʇƄUçͽŭ¯ŁÅ@±@LȹǓɃի@Ɔƾźĸóǈ⋑Jţ@@оLᆂǵ¦ƃȢŁĊȌʒ˕Þĉþȹɚǳ˖॒aାX஦x\"],\"encodeOffsets\":[[-94037,41585]]}},{\"type\":\"Feature\",\"id\":\"30\",\"properties\":{\"name\":\"Montana\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Jढ़IྕJߓ_@༛Lᦑ@စ@JѵƱĖƃƦȗǩǝ¥°ȡŗ¦ȗóʿJēýī°ŋ˖ǫVĩèJǊĵÒƏǞĉǈxêƱĈĉğȹŗǳĖ¤ĠÑĔƲĢēźxȢŢ̺ʑIUÆəĔĢ̹ɤmÒǝǉĸIɰ˕ɼ@ࡲ⒞KႢL⮀@\"],\"encodeOffsets\":[[-106544,50177]]}},{\"type\":\"Feature\",\"id\":\"31\",\"properties\":{\"name\":\"Nebraska\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ූK᥄@¥ўƱĶĊŤkЄ@ѶƽÆţƲwƲϗŚÅÆƥ»ķxŗƨóKɃĊȋ¯ɍĬōǴ˕Ⱥə㔋@ů@@ࡄွ@@၀ؔ@\"],\"encodeOffsets\":[[-105804,44036]]}},{\"type\":\"Feature\",\"id\":\"32\",\"properties\":{\"name\":\"Nevada\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ᠢIK⠵@ڱĕƛĉIĵĶ̯¼ӯèǇnƽ»ŗ৹ࠀׅҀߩ׾৹ݎઋݰJਫ਼IบબKඞV\"],\"encodeOffsets\":[[-119836,43009]]}},{\"type\":\"Feature\",\"id\":\"33\",\"properties\":{\"name\":\"New Hampshire\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@¤իÆૃƆĩaĉĸÑīƽĉbɥĉğÿউóÞVŮô°UŤÞΠƦǔôȌòèIȸˬĀƐƚýƒŘƐUĊŤɎȖw¦¼\"],\"encodeOffsets\":[[-72787,46391]]}},{\"type\":\"Feature\",\"id\":\"34\",\"properties\":{\"name\":\"New Jersey\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ˬţĵʑƏÇóŹɰÛnīķҋʽͱǟīƱɃýƐʑê̙ȀkŮKn°°þĶɦèbÞʴƐ¦ôʇǞUłŁUĬźƦçĖɂǪ²ĠŌÒϮǿ\"],\"encodeOffsets\":[[-76018,42129]]}},{\"type\":\"Feature\",\"id\":\"35\",\"properties\":{\"name\":\"New Mexico\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ҮKᑾ@૰L@н@Kᐣk࡙@ࡅᲥ@wĉĬĩඳ@@ϣ۳@L⶚സ@\"],\"encodeOffsets\":[[-109999,37889]]}},{\"type\":\"Feature\",\"id\":\"36\",\"properties\":{\"name\":\"New York\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Xǩ¯ƽþƱwǇīǟôɯ¯çƄƑ׃VóȭցnÇًÒçȷġÒĩΪçôº̰@ƼʴƆnīƆ¥̯ŭ٭ǿ˕ǵVƃ¥óƒĶʒ˫ŤϭȀÒŹLƱƚnŰķĬÛKğŘ⍻@@Ʉ@bԪʈĊŘǒþÛƜç»ɰӰĬѪKǪwȌğŤζKɚÒɼƲƲLLɰþƆȋĠ¦łͲƜŰŮКˮϤƚ֮wڰn\"],\"encodeOffsets\":[[-75104,46094]]}},{\"type\":\"Feature\",\"id\":\"37\",\"properties\":{\"name\":\"North Carolina\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ֺaڄIᵤVĬͳɻ¥˵¹¥±ȋ_XÑɰ¤ʪ¦ĊÿƲÆȭ»īĵUɃȷ˫W¯ƙŤƛĪǳɻƱˋwǿ»́ǇɱɃţˋǩỌ̀Å॑ߠऻbbĪŹƜē¹KĔਛ¦ɯǵý́ÅѓaכJxȤǔlÞƐȸŰɰJȺźɎ°ȂȌŘÈxĉͨǈƲłƾƾ¤Ȣלw\"],\"encodeOffsets\":[[-82922,37440]]}},{\"type\":\"Feature\",\"id\":\"38\",\"properties\":{\"name\":\"North Dakota\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ŎˋÅŗͽÞǇǔ˷՟aɥèǿĶĕͱ㰣VJྖIफ़㛌@\"],\"encodeOffsets\":[[-99562,50177]]}},{\"type\":\"Feature\",\"id\":\"39\",\"properties\":{\"name\":\"Ohio\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@@ૻŭ¯ÒġKŹŗȫý̯͛˕ŁġÆĩšīJŁǇxīĕýŭźƽȭ¦Źķ¯ōəkŗŘīxƜţğĉͅÞƅÑȋŘʽaòǟǪ͏@b୮Kৌ଒͞ŗŌçĊÞȀƅŚ¥ϸŎɲwʞƾζƲаł@@\"],\"encodeOffsets\":[[-82451,42987]]}},{\"type\":\"Feature\",\"id\":\"40\",\"properties\":{\"name\":\"Oklahoma\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Ⰴ@@нƾग¯๑͑ĠćĬɏĊÅóɏL¯°ȡĉĉ°ǵ£ǓŹÛòǩÒȁ@ÑĬɃȋçłīñèȡÞƧōÛŘţbçĠǉŁýçèǓUǿòǟUÏǈˋXĵȋǈÝU@࿂຿@ু@@оߪK࿦L\"],\"encodeOffsets\":[[-102489,37889]]}},{\"type\":\"Feature\",\"id\":\"41\",\"properties\":{\"name\":\"Oregon\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@þVǶĕþĵ¦ʧўġςƆɰbˌ¯ÅҢŢŎ£ʜxȺĊςôͲlŘÆაIŘƛȢÑêŗǫʝ¹Ƨīĵbýĕůēǟ̙Òŗǈaêçōˡ@໡ඝUફLࢇ@ૻ`ܕIࠗKţĬÝ˖bȌŗƦĊƒÒɤŮʈÈɄĠ܊aĬĊ̺Ѡ¯ʆ¦ƜͲŰƦīƆx\"],\"encodeOffsets\":[[-126168,47283]]}},{\"type\":\"Feature\",\"id\":\"42\",\"properties\":{\"name\":\"Pennsylvania\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@@Ƀ⍼@ĠŗÜLĸīmůƲƙźKÑŋÑ±ğɁǩèĕŹƥVīłVŁʈǝ¥óʳƏaÝɥçǝxƛğ᷇@࢓@@ޒ@ૼ@@ƾ°ӎȢ@a\"],\"encodeOffsets\":[[-81677,43267]]}},{\"type\":\"Feature\",\"id\":\"44\",\"properties\":{\"name\":\"Rhode Island\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@ÜƱǑkĶǞ\"],[\"@@Ů@°ȡĖÑĵbĕůǩͅ£¼þ@ӼɦV\"]],\"encodeOffsets\":[[[-72905,42678]],[[-73247,43026]]]}},{\"type\":\"Feature\",\"id\":\"45\",\"properties\":{\"name\":\"South Carolina\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@Ƕþɰਜ¥LēĔºźƛaĩ़a॒ߟƥ¥ȁƏǳɍǩƛƑȋ@£ĵȡōōţǩ¹ȋŹkÑǩçȋǵȗôIƜƅɤŗÒWǶÅƐɥźƥƾVĬɥƜŋƼȗłƅǪĬŹȂĕa˫ǴbĖǶǶ̂Æ\"],\"encodeOffsets\":[[-84750,35909]]}},{\"type\":\"Feature\",\"id\":\"46\",\"properties\":{\"name\":\"South Dakota\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@㰤UkīɯǳƦǉȘī@ຝōm°çƥłĉÛÑǓñŭƼȁƱxÅŤѵƾЃ@ţlĵĉѝƲ¦᥃@෕Lؓ@Iဲ`@Iߔ\"],\"encodeOffsets\":[[-106544,47047]]}},{\"type\":\"Feature\",\"id\":\"47\",\"properties\":{\"name\":\"Tennessee\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@aƲȂ੔lचǔVشܖUb`ဲUȡƽ£ŁƽƱͧǇwĊŗÇȁȋɍ¯ȹŹɯIȷůÝƏǓkwȣઋIใbۿKɥ@໷@ĊxĊƨaȬƼƒźŮ°ƼǔɄKȺ²@Æ@ĶVਲU\"],\"encodeOffsets\":[[-90168,37373]]}},{\"type\":\"Feature\",\"id\":\"48\",\"properties\":{\"name\":\"Texas\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ເ@@࿁ÞVȌǇĶˌWÐǇǠVȀñǔVèçłþǊèğŤaÜŗƨŎȢÝòçĬèŁɄȌÒīȂ@ǪÑÜñǔźǶ¤Ċ¯ȢĊ°¯ɐKÆôɐĉĈī͒ğĖýǔ¤Ţ@ѿ@࡯ȂȁJǿɲͽbǵĕɍĉĕŗÑĕÜǇȡ̗ôĉƏKѩŗƽÜƒŋīýx¥ţĖ»`ƻƻǓʩȹԑə¹ƱÅKºȷīŀÑwɚɍǇçƱ¤wƱȋƽȗ́ụ̆ğxwōĪ¯əÛUKůþçzʧĠĕxǇòƛʳĕŁŎȡ¤ʽUɥƐǟbŹŎǩţłýʨƱƲlźçƒxŢŁƆēbƛŤ¯ƲůƐǳŘĕʪĉèōȮǒŁŤǵł¥ôǓÞŹȀο¤əUȋÞ¥ĕȭƱǩğ˫»IŗǓƏKȷźԳȺķŌȫłƛʈUɎƛǪƴġĪ͛ƜǩȘƛèƱǔɃĔƥɜů°īĪxĊᲦ@@ࡆl࡚Lᐤ@ূ@\"],\"encodeOffsets\":[[-104256,37378]]}},{\"type\":\"Feature\",\"id\":\"49\",\"properties\":{\"name\":\"Utah\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@रJ@ࡃှ@I༻K܉bġ@ও௧JᲣIL⠶ཆ@\"],\"encodeOffsets\":[[-114856,43004]]}},{\"type\":\"Feature\",\"id\":\"50\",\"properties\":{\"name\":\"Vermont\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@VĉŗƏþƑƏƙ˫ÿJȷñçóȋƥǓÝΟVţó¯UŭôÝڻbUôׄƃƒ°èóɰĬǠxǈýƲ°ƾWǪ࢈UڲV\"],\"encodeOffsets\":[[-73219,46094]]}},{\"type\":\"Feature\",\"id\":\"51\",\"properties\":{\"name\":\"Virginia\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@źbŋƛŗ¹éȗǩ̹ƛÝ¯Řôʴɦ͞ɰº\"],[\"@@l@£@x@\"],[\"@@Ѫ˭ĠǊźaĢç@ůǪ£ŌýÞţóƅĵÝţēɦ¤ƃ̎ÅĊŁɼřŁɻĬǿŗĕaŁłÛŗĵǩƄ¥¯Ʋīвwł̹ᵣUڃJֹbכxေVҌŤÆĠǈVòŰÈ@Ṵ̈Ű͐ɤaçŚƛƚçłLǊŌŘēɐ°Ϣǈ¹ƨòJƲĢƆƼŮÞƴǔƼÜȘƜŗƐĖèǶ̘łñϸ;°ʞ\"]],\"encodeOffsets\":[[[-77207,38926]],[[-77840,38865]],[[-80230,40413]]]}},{\"type\":\"Feature\",\"id\":\"53\",\"properties\":{\"name\":\"Washington\"},\"geometry\":{\"type\":\"MultiPolygon\",\"coordinates\":[[\"@@UਧL૯açŎƧJƥ჏JŗÅͱkρóȹĉʛwō¤ҡšÆˋ°ɯaρƅѝĢ¥ʨýĶǵĖýUƅwƥĬƱů»ǇôŘŎÒǝǪřҖçÒğ͒ǓŮçʞĠǔǠýΈŁɼJɼ£ɜ¤łñȢJƐǿĶbnʝÒɥĊxĉȘxȌƐȖōþUƒĉƲ¦ŌÇźƃnůĬĠ⸈@\"],[\"@@ŌkǟƅÞ¦è\"],[\"@@ĠŌŮƅŗȕbł\"]],\"encodeOffsets\":[[[-119842,50177]],[[-125663,49470]],[[-125977,49751]]]}},{\"type\":\"Feature\",\"id\":\"54\",\"properties\":{\"name\":\"West Virginia\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@@ޑ࢔@UѝǔþǔƜŌǔŮʞÑĠƒIþÜƜýƜ@Īɻğǉѩˮ¯ʝϷͽŁòǵ̗ĕçƏƛŘÛȗǓƻÝƳƻŭġƅIƱƧñºϡǇɏ¯ŗĔǉŋŁKƙèřƜbèŋbǉĬ£ĬƅŮĵǈxʪɚlŎĸ°¥źƾȮŮŹĖþwĬłǈĬIĪŢĢÅł͜˖þ̰ŘȬLźÑĢŮ°\"],\"encodeOffsets\":[[-82451,41613]]}},{\"type\":\"Feature\",\"id\":\"55\",\"properties\":{\"name\":\"Wisconsin\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ƾ»ĠƛࡼǝάůŌάĉĬŁǪķUƥÿŗȢmýšźĕĵǉmƏȕ¹ƅĪwźĔƒǔǪÞƐɄǪ°aōţĵɻΓÛȗLƏĕ¯ýȋǇñŁķʿxȷĸȁʑࠡ@༏bÑł̗ĬÝƄȌĶĸůĈUŰ¯ĬxƄǇȂƅʅƜ¥ŌʳĢēĠǫbəƲÒ̮kƜĪźŁłĩXbŢȖǶʈèº¼@ӼǠèÜȌUגƚɎĀôÑŗōˠƛŤ_\"],\"encodeOffsets\":[[-92585,47687]]}},{\"type\":\"Feature\",\"id\":\"56\",\"properties\":{\"name\":\"Wyoming\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@ᦒ@༜KJေ@ဿටIᇅJेIွ@@ࡄ@ᐎIѶဆ@\"],\"encodeOffsets\":[[-111698,46083]]}},{\"type\":\"Feature\",\"id\":\"72\",\"properties\":{\"name\":\"Puerto Rico\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[\"@@˓nŻÝ¹ȋa°ȤīƚƨźŘwҢ@ӎ¯ǪÅLƏĕaēƛͳóǵ°\"],\"encodeOffsets\":[[-68043,18416]]}}],\"UTF8Encoding\":true},{\"Alaska\":{\"left\":-131,\"top\":25,\"width\":15},\"Hawaii\":{\"left\":-110,\"top\":28,\"width\":5},\"Puerto Rico\":{\"left\":-76,\"top\":26,\"width\":2}});}));"},{"title":"","date":"2020-10-15T20:13:29.153Z","updated":"2019-04-27T04:08:33.618Z","comments":true,"path":"js/qunit.js","permalink":"https://knowledge.capitaltwo.ga/js/qunit.js","excerpt":"","text":"/* * QUnit - A JavaScript Unit Testing Framework * * http://docs.jquery.com/QUnit * * Copyright (c) 2009 John Resig, Jörn Zaefferer * Dual licensed under the MIT (MIT-LICENSE.txt) * and GPL (GPL-LICENSE.txt) licenses. */ (function(window) { var QUnit = { // Initialize the configuration options init: function() { config = { stats: { all: 0, bad: 0 }, moduleStats: { all: 0, bad: 0 }, started: +new Date, updateRate: 1000, blocking: false, autorun: false, assertions: [], filters: [], queue: [] }; var tests = id(\"qunit-tests\"), banner = id(\"qunit-banner\"), result = id(\"qunit-testresult\"); if ( tests ) { tests.innerHTML = \"\"; } if ( banner ) { banner.className = \"\"; } if ( result ) { result.parentNode.removeChild( result ); } }, // call on start of module test to prepend name to all tests module: function(name, testEnvironment) { config.currentModule = name; synchronize(function() { if ( config.currentModule ) { QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all ); } config.currentModule = name; config.moduleTestEnvironment = testEnvironment; config.moduleStats = { all: 0, bad: 0 }; QUnit.moduleStart( name, testEnvironment ); }); }, asyncTest: function(testName, expected, callback) { if ( arguments.length === 2 ) { callback = expected; expected = 0; } QUnit.test(testName, expected, callback, true); }, test: function(testName, expected, callback, async) { var name = testName, testEnvironment, testEnvironmentArg; if ( arguments.length === 2 ) { callback = expected; expected = null; } // is 2nd argument a testEnvironment? if ( expected && typeof expected === 'object') { testEnvironmentArg = expected; expected = null; } if ( config.currentModule ) { name = config.currentModule + \" module: \" + name; } if ( !validTest(name) ) { return; } synchronize(function() { QUnit.testStart( testName ); testEnvironment = extend({ setup: function() {}, teardown: function() {} }, config.moduleTestEnvironment); if (testEnvironmentArg) { extend(testEnvironment,testEnvironmentArg); } // allow utility functions to access the current test environment QUnit.current_testEnvironment = testEnvironment; config.assertions = []; config.expected = expected; try { if ( !config.pollution ) { saveGlobal(); } testEnvironment.setup.call(testEnvironment); } catch(e) { QUnit.ok( false, \"Setup failed on \" + name + \": \" + e.message ); } if ( async ) { QUnit.stop(); } try { callback.call(testEnvironment); } catch(e) { fail(\"Test \" + name + \" died, exception and test follows\", e, callback); QUnit.ok( false, \"Died on test #\" + (config.assertions.length + 1) + \": \" + e.message ); // else next test will carry the responsibility saveGlobal(); // Restart the tests if they're blocking if ( config.blocking ) { start(); } } }); synchronize(function() { try { checkPollution(); testEnvironment.teardown.call(testEnvironment); } catch(e) { QUnit.ok( false, \"Teardown failed on \" + name + \": \" + e.message ); } try { QUnit.reset(); } catch(e) { fail(\"reset() failed, following Test \" + name + \", exception and reset fn follows\", e, reset); } if ( config.expected && config.expected != config.assertions.length ) { QUnit.ok( false, \"Expected \" + config.expected + \" assertions, but \" + config.assertions.length + \" were run\" ); } var good = 0, bad = 0, tests = id(\"qunit-tests\"); config.stats.all += config.assertions.length; config.moduleStats.all += config.assertions.length; if ( tests ) { var ol = document.createElement(\"ol\"); ol.style.display = \"none\"; for ( var i = 0; i < config.assertions.length; i++ ) { var assertion = config.assertions[i]; var li = document.createElement(\"li\"); li.className = assertion.result ? \"pass\" : \"fail\"; li.appendChild(document.createTextNode(assertion.message || \"(no message)\")); ol.appendChild( li ); if ( assertion.result ) { good++; } else { bad++; config.stats.bad++; config.moduleStats.bad++; } } var b = document.createElement(\"strong\"); b.innerHTML = name + \" (\" + bad + \", \" + good + \", \" + config.assertions.length + \")\"; addEvent(b, \"click\", function() { var next = b.nextSibling, display = next.style.display; next.style.display = display === \"none\" ? \"block\" : \"none\"; }); addEvent(b, \"dblclick\", function(e) { var target = e && e.target ? e.target : window.event.srcElement; if ( target.nodeName.toLowerCase() === \"strong\" ) { var text = \"\", node = target.firstChild; while ( node.nodeType === 3 ) { text += node.nodeValue; node = node.nextSibling; } text = text.replace(/(^\\s*|\\s*$)/g, \"\"); if ( window.location ) { window.location.href = window.location.href.match(/^(.+?)(\\?.*)?$/)[1] + \"?\" + encodeURIComponent(text); } } }); var li = document.createElement(\"li\"); li.className = bad ? \"fail\" : \"pass\"; li.appendChild( b ); li.appendChild( ol ); tests.appendChild( li ); if ( bad ) { var toolbar = id(\"qunit-testrunner-toolbar\"); if ( toolbar ) { toolbar.style.display = \"block\"; id(\"qunit-filter-pass\").disabled = null; id(\"qunit-filter-missing\").disabled = null; } } } else { for ( var i = 0; i < config.assertions.length; i++ ) { if ( !config.assertions[i].result ) { bad++; config.stats.bad++; config.moduleStats.bad++; } } } QUnit.testDone( testName, bad, config.assertions.length ); if ( !window.setTimeout && !config.queue.length ) { done(); } }); if ( window.setTimeout && !config.doneTimer ) { config.doneTimer = window.setTimeout(function(){ if ( !config.queue.length ) { done(); } else { synchronize( done ); } }, 13); } }, /** * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through. */ expect: function(asserts) { config.expected = asserts; }, /** * Asserts true. * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" ); */ ok: function(a, msg) { QUnit.log(a, msg); config.assertions.push({ result: !!a, message: msg }); }, /** * Checks that the first two arguments are equal, with an optional message. * Prints out both actual and expected values. * * Prefered to ok( actual == expected, message ) * * @example equal( format(\"Received {0} bytes.\", 2), \"Received 2 bytes.\" ); * * @param Object actual * @param Object expected * @param String message (optional) */ equal: function(actual, expected, message) { push(expected == actual, actual, expected, message); }, notEqual: function(actual, expected, message) { push(expected != actual, actual, expected, message); }, deepEqual: function(a, b, message) { push(QUnit.equiv(a, b), a, b, message); }, notDeepEqual: function(a, b, message) { push(!QUnit.equiv(a, b), a, b, message); }, strictEqual: function(actual, expected, message) { push(expected === actual, actual, expected, message); }, notStrictEqual: function(actual, expected, message) { push(expected !== actual, actual, expected, message); }, start: function() { // A slight delay, to avoid any current callbacks if ( window.setTimeout ) { window.setTimeout(function() { if ( config.timeout ) { clearTimeout(config.timeout); } config.blocking = false; process(); }, 13); } else { config.blocking = false; process(); } }, stop: function(timeout) { config.blocking = true; if ( timeout && window.setTimeout ) { config.timeout = window.setTimeout(function() { QUnit.ok( false, \"Test timed out\" ); QUnit.start(); }, timeout); } }, /** * Resets the test setup. Useful for tests that modify the DOM. */ reset: function() { if ( window.jQuery ) { jQuery(\"#main\").html( config.fixture ); jQuery.event.global = {}; jQuery.ajaxSettings = extend({}, config.ajaxSettings); } }, /** * Trigger an event on an element. * * @example triggerEvent( document.body, \"click\" ); * * @param DOMElement elem * @param String type */ triggerEvent: function( elem, type, event ) { if ( document.createEvent ) { event = document.createEvent(\"MouseEvents\"); event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null); elem.dispatchEvent( event ); } else if ( elem.fireEvent ) { elem.fireEvent(\"on\"+type); } }, // Safe object type checking is: function( type, obj ) { return Object.prototype.toString.call( obj ) === \"[object \"+ type +\"]\"; }, // Logging callbacks done: function(failures, total) {}, log: function(result, message) {}, testStart: function(name) {}, testDone: function(name, failures, total) {}, moduleStart: function(name, testEnvironment) {}, moduleDone: function(name, failures, total) {} }; // Backwards compatibility, deprecated QUnit.equals = QUnit.equal; QUnit.same = QUnit.deepEqual; // Maintain internal state var config = { // The queue of tests to run queue: [], // block until document ready blocking: true }; // Load paramaters (function() { var location = window.location || { search: \"\", protocol: \"file:\" }, GETParams = location.search.slice(1).split('&'); for ( var i = 0; i < GETParams.length; i++ ) { GETParams[i] = decodeURIComponent( GETParams[i] ); if ( GETParams[i] === \"noglobals\" ) { GETParams.splice( i, 1 ); i--; config.noglobals = true; } else if ( GETParams[i].search('=') > -1 ) { GETParams.splice( i, 1 ); i--; } } // restrict modules/tests by get parameters config.filters = GETParams; // Figure out if we're running the tests from a server or not QUnit.isLocal = !!(location.protocol === 'file:'); })(); // Expose the API as global variables, unless an 'exports' // object exists, in that case we assume we're in CommonJS if ( typeof exports === \"undefined\" || typeof require === \"undefined\" ) { extend(window, QUnit); window.QUnit = QUnit; } else { extend(exports, QUnit); exports.QUnit = QUnit; } if ( typeof document === \"undefined\" || document.readyState === \"complete\" ) { config.autorun = true; } addEvent(window, \"load\", function() { // Initialize the config, saving the execution queue var oldconfig = extend({}, config); QUnit.init(); extend(config, oldconfig); config.blocking = false; var userAgent = id(\"qunit-userAgent\"); if ( userAgent ) { userAgent.innerHTML = navigator.userAgent; } var toolbar = id(\"qunit-testrunner-toolbar\"); if ( toolbar ) { toolbar.style.display = \"none\"; var filter = document.createElement(\"input\"); filter.type = \"checkbox\"; filter.id = \"qunit-filter-pass\"; filter.disabled = true; addEvent( filter, \"click\", function() { var li = document.getElementsByTagName(\"li\"); for ( var i = 0; i < li.length; i++ ) { if ( li[i].className.indexOf(\"pass\") > -1 ) { li[i].style.display = filter.checked ? \"none\" : \"\"; } } }); toolbar.appendChild( filter ); var label = document.createElement(\"label\"); label.setAttribute(\"for\", \"qunit-filter-pass\"); label.innerHTML = \"Hide passed tests\"; toolbar.appendChild( label ); var missing = document.createElement(\"input\"); missing.type = \"checkbox\"; missing.id = \"qunit-filter-missing\"; missing.disabled = true; addEvent( missing, \"click\", function() { var li = document.getElementsByTagName(\"li\"); for ( var i = 0; i < li.length; i++ ) { if ( li[i].className.indexOf(\"fail\") > -1 && li[i].innerHTML.indexOf('missing test - untested code is broken code') > - 1 ) { li[i].parentNode.parentNode.style.display = missing.checked ? \"none\" : \"block\"; } } }); toolbar.appendChild( missing ); label = document.createElement(\"label\"); label.setAttribute(\"for\", \"qunit-filter-missing\"); label.innerHTML = \"Hide missing tests (untested code is broken code)\"; toolbar.appendChild( label ); } var main = id('main'); if ( main ) { config.fixture = main.innerHTML; } if ( window.jQuery ) { config.ajaxSettings = window.jQuery.ajaxSettings; } QUnit.start(); }); function done() { if ( config.doneTimer && window.clearTimeout ) { window.clearTimeout( config.doneTimer ); config.doneTimer = null; } if ( config.queue.length ) { config.doneTimer = window.setTimeout(function(){ if ( !config.queue.length ) { done(); } else { synchronize( done ); } }, 13); return; } config.autorun = true; // Log the last module results if ( config.currentModule ) { QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all ); } var banner = id(\"qunit-banner\"), tests = id(\"qunit-tests\"), html = ['Tests completed in ', +new Date - config.started, ' milliseconds.', '', config.stats.all - config.stats.bad, ' tests of ', config.stats.all, ' passed, ', config.stats.bad,' failed.'].join(''); if ( banner ) { banner.className = (config.stats.bad ? \"qunit-fail\" : \"qunit-pass\"); } if ( tests ) { var result = id(\"qunit-testresult\"); if ( !result ) { result = document.createElement(\"p\"); result.id = \"qunit-testresult\"; result.className = \"result\"; tests.parentNode.insertBefore( result, tests.nextSibling ); } result.innerHTML = html; } QUnit.done( config.stats.bad, config.stats.all ); } function validTest( name ) { var i = config.filters.length, run = false; if ( !i ) { return true; } while ( i-- ) { var filter = config.filters[i], not = filter.charAt(0) == '!'; if ( not ) { filter = filter.slice(1); } if ( name.indexOf(filter) !== -1 ) { return !not; } if ( not ) { run = true; } } return run; } function push(result, actual, expected, message) { message = message || (result ? \"okay\" : \"failed\"); QUnit.ok( result, result ? message + \": \" + QUnit.jsDump.parse(expected) : message + \", expected: \" + QUnit.jsDump.parse(expected) + \" result: \" + QUnit.jsDump.parse(actual) ); } function synchronize( callback ) { config.queue.push( callback ); if ( config.autorun && !config.blocking ) { process(); } } function process() { var start = (new Date()).getTime(); while ( config.queue.length && !config.blocking ) { if ( config.updateRate 0 ) { ok( false, \"Deleted global variable(s): \" + deletedGlobals.join(\", \") ); config.expected++; } } // returns a new Array with the elements that are in a but not in b function diff( a, b ) { var result = a.slice(); for ( var i = 0; i < result.length; i++ ) { for ( var j = 0; j < b.length; j++ ) { if ( result[i] === b[j] ) { result.splice(i, 1); i--; break; } } } return result; } function fail(message, exception, callback) { if ( typeof console !== \"undefined\" && console.error && console.warn ) { console.error(message); console.error(exception); console.warn(callback.toString()); } else if ( window.opera && opera.postError ) { opera.postError(message, exception, callback.toString); } } function extend(a, b) { for ( var prop in b ) { a[prop] = b[prop]; } return a; } function addEvent(elem, type, fn) { if ( elem.addEventListener ) { elem.addEventListener( type, fn, false ); } else if ( elem.attachEvent ) { elem.attachEvent( \"on\" + type, fn ); } else { fn(); } } function id(name) { return !!(typeof document !== \"undefined\" && document && document.getElementById) && document.getElementById( name ); } // Test for equality any JavaScript type. // Discussions and reference: http://philrathe.com/articles/equiv // Test suites: http://philrathe.com/tests/equiv // Author: Philippe Rathé QUnit.equiv = function () { var innerEquiv; // the real equiv function var callers = []; // stack to decide between skip/abort functions var parents = []; // stack to avoiding loops from circular referencing // Determine what is o. function hoozit(o) { if (QUnit.is(\"String\", o)) { return \"string\"; } else if (QUnit.is(\"Boolean\", o)) { return \"boolean\"; } else if (QUnit.is(\"Number\", o)) { if (isNaN(o)) { return \"nan\"; } else { return \"number\"; } } else if (typeof o === \"undefined\") { return \"undefined\"; // consider: typeof null === object } else if (o === null) { return \"null\"; // consider: typeof [] === object } else if (QUnit.is( \"Array\", o)) { return \"array\"; // consider: typeof new Date() === object } else if (QUnit.is( \"Date\", o)) { return \"date\"; // consider: /./ instanceof Object; // /./ instanceof RegExp; // typeof /./ === \"function\"; // => false in IE and Opera, // true in FF and Safari } else if (QUnit.is( \"RegExp\", o)) { return \"regexp\"; } else if (typeof o === \"object\") { return \"object\"; } else if (QUnit.is( \"Function\", o)) { return \"function\"; } else { return undefined; } } // Call the o related callback with the given arguments. function bindCallbacks(o, callbacks, args) { var prop = hoozit(o); if (prop) { if (hoozit(callbacks[prop]) === \"function\") { return callbacks[prop].apply(callbacks, args); } else { return callbacks[prop]; // or undefined } } } var callbacks = function () { // for string, boolean, number and null function useStrictEquality(b, a) { if (b instanceof a.constructor || a instanceof b.constructor) { // to catch short annotaion VS 'new' annotation of a declaration // e.g. var i = 1; // var j = new Number(1); return a == b; } else { return a === b; } } return { \"string\": useStrictEquality, \"boolean\": useStrictEquality, \"number\": useStrictEquality, \"null\": useStrictEquality, \"undefined\": useStrictEquality, \"nan\": function (b) { return isNaN(b); }, \"date\": function (b, a) { return hoozit(b) === \"date\" && a.valueOf() === b.valueOf(); }, \"regexp\": function (b, a) { return hoozit(b) === \"regexp\" && a.source === b.source && // the regex itself a.global === b.global && // and its modifers (gmi) ... a.ignoreCase === b.ignoreCase && a.multiline === b.multiline; }, // - skip when the property is a method of an instance (OOP) // - abort otherwise, // initial === would have catch identical references anyway \"function\": function () { var caller = callers[callers.length - 1]; return caller !== Object && typeof caller !== \"undefined\"; }, \"array\": function (b, a) { var i, j, loop; var len; // b could be an object literal here if ( ! (hoozit(b) === \"array\")) { return false; } len = a.length; if (len !== b.length) { // safe and faster return false; } //track reference to avoid circular references parents.push(a); for (i = 0; i < len; i++) { loop = false; for(j=0;j= 0) { type = \"array\"; } else { type = typeof obj; } return type; }, separator:function() { return this.multiline ? this.HTML ? '' : '\\n' : this.HTML ? '&nbsp;' : ' '; }, indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing if ( !this.multiline ) return ''; var chr = this.indentChar; if ( this.HTML ) chr = chr.replace(/\\t/g,' ').replace(/ /g,'&nbsp;'); return Array( this._depth_ + (extra||0) ).join(chr); }, up:function( a ) { this._depth_ += a || 1; }, down:function( a ) { this._depth_ -= a || 1; }, setParser:function( name, parser ) { this.parsers[name] = parser; }, // The next 3 are exposed so you can use them quote:quote, literal:literal, join:join, // _depth_: 1, // This is the list of parsers, to modify them, use jsDump.setParser parsers:{ window: '[Window]', document: '[Document]', error:'[ERROR]', //when no parser is found, shouldn't happen unknown: '[Unknown]', 'null':'null', undefined:'undefined', 'function':function( fn ) { var ret = 'function', name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE if ( name ) ret += ' ' + name; ret += '('; ret = [ ret, this.parse( fn, 'functionArgs' ), '){'].join(''); return join( ret, this.parse(fn,'functionCode'), '}' ); }, array: array, nodelist: array, arguments: array, object:function( map ) { var ret = [ ]; this.up(); for ( var key in map ) ret.push( this.parse(key,'key') + ': ' + this.parse(map[key]) ); this.down(); return join( '{', ret, '}' ); }, node:function( node ) { var open = this.HTML ? '&lt;' : ''; var tag = node.nodeName.toLowerCase(), ret = open + tag; for ( var a in this.DOMAttrs ) { var val = node[this.DOMAttrs[a]]; if ( val ) ret += ' ' + a + '=' + this.parse( val, 'attribute' ); } return ret + close + open + '/' + tag + close; }, functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function var l = fn.length; if ( !l ) return ''; var args = Array(l); while ( l-- ) args[l] = String.fromCharCode(97+l);//97 is 'a' return ' ' + args.join(', ') + ' '; }, key:quote, //object calls it internally, the key part of an item in a map functionCode:'[code]', //function calls it internally, it's the content of the function attribute:quote, //node calls it internally, it's an html attribute value string:quote, date:quote, regexp:literal, //regex number:literal, 'boolean':literal }, DOMAttrs:{//attributes to dump from nodes, name=>realName id:'id', name:'name', 'class':'className' }, HTML:false,//if true, entities are escaped ( , \\t, space and \\n ) indentChar:' ',//indentation unit multiline:false //if true, items in a collection, are separated by a \\n, else just a space. }; return jsDump; })(); })(this);"},{"title":"","date":"2020-10-15T20:13:29.149Z","updated":"2019-04-27T04:08:33.837Z","comments":true,"path":"src/shCore.js","permalink":"https://knowledge.capitaltwo.ga/src/shCore.js","excerpt":"","text":"var XRegExp; (function () { function s(f, i) { if (!XRegExp.isRegExp(f)) throw TypeError(\"type RegExp expected\"); var g = f._xregexp; f = XRegExp(f.source, t(f) + (i || \"\")); if (g) f._xregexp = { source: g.source, captureNames: g.captureNames ? g.captureNames.slice(0) : null }; return f } function t(f) { return (f.global ? \"g\" : \"\") + (f.ignoreCase ? \"i\" : \"\") + (f.multiline ? \"m\" : \"\") + (f.extended ? \"x\" : \"\") + (f.sticky ? \"y\" : \"\") } function z(f, i, g, a) { var b = v.length, c, d, e; A = true; try { for (; b--; ) { e = v[b]; if (g & e.scope && (!e.trigger || e.trigger.call(a))) { e.pattern.lastIndex = i; if ((d = e.pattern.exec(f)) && d.index === i) { c = { output: e.handler.call(a, d, g), match: d }; break } } } } catch (h) { throw h } finally { A = false } return c } function B(f, i, g) { if (Array.prototype.indexOf) return f.indexOf(i, g); for (g = g || 0; g < f.length; g++) if (f[g] === i) return g; return -1 } XRegExp = function (f, i) { var g = [], a = XRegExp.OUTSIDE_CLASS, b = 0, c, d; if (XRegExp.isRegExp(f)) { if (i !== undefined) throw TypeError(\"can't supply flags when constructing one RegExp from another\"); return s(f) } if (A) throw Error(\"can't call the XRegExp constructor within token definition functions\"); i = i || \"\"; for (c = { hasNamedCapture: false, captureNames: [], hasFlag: function (e) { return i.indexOf(e) > -1 }, setFlag: function (e) { i += e } }; b < f.length; ) if (d = z(f, b, a, c)) { g.push(d.output); b += d.match[0].length || 1 } else if (d = o.exec.call(C[a], f.slice(b))) { g.push(d[0]); b += d[0].length } else { d = f.charAt(b); if (d === \"[\") a = XRegExp.INSIDE_CLASS; else if (d === \"]\") a = XRegExp.OUTSIDE_CLASS; g.push(d); b++ } g = RegExp(g.join(\"\"), o.replace.call(i, D, \"\")); g._xregexp = { source: f, captureNames: c.hasNamedCapture ? c.captureNames : null }; return g }; XRegExp.version = \"1.5.0\"; XRegExp.INSIDE_CLASS = 1; XRegExp.OUTSIDE_CLASS = 2; var q = /\\$(?:(\\d\\d?|[$&`'])|{([$\\w]+)})/g, D = /[^gimy]+|([\\s\\S])(?=[\\s\\S]*\\1)/g, w = /^(?:[?*+]|{\\d+(?:,\\d*)?})\\??/, A = false, v = [], o = { exec: RegExp.prototype.exec, test: RegExp.prototype.test, match: String.prototype.match, replace: String.prototype.replace, split: String.prototype.split }, F = o.exec.call(/()??/, \"\")[1] === undefined, x = function () { var f = /^/g; o.test.call(f, \"\"); return !f.lastIndex } (), G = function () { var f = /x/g; o.replace.call(\"x\", f, \"\"); return !f.lastIndex } (), y = RegExp.prototype.sticky !== undefined, C = {}; C[XRegExp.INSIDE_CLASS] = /^(?:\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u[\\dA-Fa-f]{4}|c[A-Za-z]|[\\s\\S]))/; C[XRegExp.OUTSIDE_CLASS] = /^(?:\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u[\\dA-Fa-f]{4}|c[A-Za-z]|[\\s\\S])|\\(\\?[:=!]|[?*+]\\?|{\\d+(?:,\\d*)?}\\??)/; XRegExp.addToken = function (f, i, g, a) { v.push({ pattern: s(f, \"g\" + (y ? \"y\" : \"\")), handler: i, scope: g || XRegExp.OUTSIDE_CLASS, trigger: a || null }) }; XRegExp.cache = function (f, i) { var g = f + \"/\" + (i || \"\"); return XRegExp.cache[g] || (XRegExp.cache[g] = XRegExp(f, i)) }; XRegExp.copyAsGlobal = function (f) { return s(f, \"g\") }; XRegExp.escape = function (f) { return f.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\") }; XRegExp.execAt = function (f, i, g, a) { i = s(i, \"g\" + (a && y ? \"y\" : \"\")); i.lastIndex = g = g || 0; f = i.exec(f); return a ? f && f.index === g ? f : null : f }; XRegExp.freezeTokens = function () { XRegExp.addToken = function () { throw Error(\"can't run addToken after freezeTokens\") } }; XRegExp.isRegExp = function (f) { return Object.prototype.toString.call(f) === \"[object RegExp]\" }; XRegExp.iterate = function (f, i, g, a) { for (var b = s(i, \"g\"), c = -1, d; d = b.exec(f); ) { g.call(a, d, ++c, f, b); b.lastIndex === d.index && b.lastIndex++ } if (i.global) i.lastIndex = 0 }; XRegExp.matchChain = function (f, i) { return function g(a, b) { var c = i[b].regex ? i[b] : { regex: i[b] }, d = s(c.regex, \"g\"), e = [], h; for (h = 0; h < a.length; h++) XRegExp.iterate(a[h], d, function (j) { e.push(c.backref ? j[c.backref] || \"\" : j[0]) }); return b === i.length - 1 || !e.length ? e : g(e, b + 1) } ([f], 0) }; RegExp.prototype.apply = function (f, i) { return this.exec(i[0]) }; RegExp.prototype.call = function (f, i) { return this.exec(i) }; RegExp.prototype.exec = function (f) { var i = o.exec.apply(this, arguments), g; if (i) { if (!F && i.length > 1 && B(i, \"\") > -1) { g = RegExp(this.source, o.replace.call(t(this), \"g\", \"\")); o.replace.call(f.toString().slice(i.index), g, function () { for (var b = 1; b < arguments.length - 2; b++) if (arguments[b] === undefined) i[b] = undefined }) } if (this._xregexp && this._xregexp.captureNames) for (var a = 1; a < i.length; a++) if (g = this._xregexp.captureNames[a - 1]) i[g] = i[a]; !x && this.global && !i[0].length && this.lastIndex > i.index && this.lastIndex-- } return i }; if (!x) RegExp.prototype.test = function (f) { (f = o.exec.call(this, f)) && this.global && !f[0].length && this.lastIndex > f.index && this.lastIndex--; return !!f }; String.prototype.match = function (f) { XRegExp.isRegExp(f) || (f = RegExp(f)); if (f.global) { var i = o.match.apply(this, arguments); f.lastIndex = 0; return i } return f.exec(this) }; String.prototype.replace = function (f, i) { var g = XRegExp.isRegExp(f), a, b; if (g && typeof i.valueOf() === \"string\" && i.indexOf(\"${\") === -1 && G) return o.replace.apply(this, arguments); if (g) { if (f._xregexp) a = f._xregexp.captureNames } else f += \"\"; if (typeof i === \"function\") b = o.replace.call(this, f, function () { if (a) { arguments[0] = new String(arguments[0]); for (var c = 0; c < a.length; c++) if (a[c]) arguments[0][a[c]] = arguments[c + 1] } if (g && f.global) f.lastIndex = arguments[arguments.length - 2] + arguments[0].length; return i.apply(null, arguments) }); else { b = this + \"\"; b = o.replace.call(b, f, function () { var c = arguments; return o.replace.call(i, q, function (d, e, h) { if (e) switch (e) { case \"$\": return \"$\"; case \"&\": return c[0]; case \"`\": return c[c.length - 1].slice(0, c[c.length - 2]); case \"'\": return c[c.length - 1].slice(c[c.length - 2] + c[0].length); default: h = \"\"; e = +e; if (!e) return d; for (; e > c.length - 3; ) { h = String.prototype.slice.call(e, -1) + h; e = Math.floor(e / 10) } return (e ? c[e] || \"\" : \"$\") + h } else { e = +h; if (e -1 ? c[e + 1] : d } }) }) } if (g && f.global) f.lastIndex = 0; return b }; String.prototype.split = function (f, i) { if (!XRegExp.isRegExp(f)) return o.split.apply(this, arguments); var g = this + \"\", a = [], b = 0, c, d; if (i === undefined || +i < 0) i = Infinity; else { i = Math.floor(+i); if (!i) return [] } for (f = XRegExp.copyAsGlobal(f); c = f.exec(g); ) { if (f.lastIndex > b) { a.push(g.slice(b, c.index)); c.length > 1 && c.index < g.length && Array.prototype.push.apply(a, c.slice(1)); d = c[0].length; b = f.lastIndex; if (a.length >= i) break } f.lastIndex === c.index && f.lastIndex++ } if (b === g.length) { if (!o.test.call(f, \"\") || d) a.push(\"\") } else a.push(g.slice(b)); return a.length > i ? a.slice(0, i) : a }; XRegExp.addToken(/\\(\\?#[^)]*\\)/, function (f) { return o.test.call(w, f.input.slice(f.index + f[0].length)) ? \"\" : \"(?:)\" }); XRegExp.addToken(/\\((?!\\?)/, function () { this.captureNames.push(null); return \"(\" }); XRegExp.addToken(/\\(\\?/, function (f) { this.captureNames.push(f[1]); this.hasNamedCapture = true; return \"(\" }); XRegExp.addToken(/\\\\k/, function (f) { var i = B(this.captureNames, f[1]); return i > -1 ? \"\\\\\" + (i + 1) + (isNaN(f.input.charAt(f.index + f[0].length)) ? \"\" : \"(?:)\") : f[0] }); XRegExp.addToken(/\\[\\^?]/, function (f) { return f[0] === \"[]\" ? \"\\\\b\\\\B\" : \"[\\\\s\\\\S]\" }); XRegExp.addToken(/^\\(\\?([imsx]+)\\)/, function (f) { this.setFlag(f[1]); return \"\" }); XRegExp.addToken(/(?:\\s+|#.*)+/, function (f) { return o.test.call(w, f.input.slice(f.index + f[0].length)) ? \"\" : \"(?:)\" }, XRegExp.OUTSIDE_CLASS, function () { return this.hasFlag(\"x\") }); XRegExp.addToken(/\\./, function () { return \"[\\\\s\\\\S]\" }, XRegExp.OUTSIDE_CLASS, function () { return this.hasFlag(\"s\") }) })(); /** * SyntaxHighlighter * http://alexgorbatchev.com/SyntaxHighlighter * * SyntaxHighlighter is donationware. If you are using it, please donate. * http://alexgorbatchev.com/SyntaxHighlighter/donate.html * * @version * 3.0.83 (July 02 2010) * * @copyright * Copyright (C) 2004-2010 Alex Gorbatchev. * * @license * Dual licensed under the MIT and GPL licenses. */ // // Begin anonymous function. This is used to contain local scope variables without polutting global scope. // var SyntaxHighlighter = function() { // CommonJS if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined') { XRegExp = require('XRegExp').XRegExp; } // Shortcut object which will be assigned to the SyntaxHighlighter variable. // This is a shorthand for local reference in order to avoid long namespace // references to SyntaxHighlighter.whatever... var sh = { defaults : { /** Additional CSS class names to be added to highlighter elements. */ 'class-name' : '', /** First line number. */ 'first-line' : 1, /** * Pads line numbers. Possible values are: * * false - don't pad line numbers. * true - automaticaly pad numbers with minimum required number of leading zeroes. * [int] - length up to which pad line numbers. */ 'pad-line-numbers' : false, /** Lines to highlight. */ 'highlight' : null, /** Title to be displayed above the code block. */ 'title' : null, /** Enables or disables smart tabs. */ 'smart-tabs' : true, /** Gets or sets tab size. */ 'tab-size' : 4, /** Enables or disables gutter. */ 'gutter' : true, /** Enables or disables toolbar. */ 'toolbar' : true, /** Enables quick code copy and paste from double click. */ 'quick-code' : true, /** Forces code view to be collapsed. */ 'collapse' : false, /** Enables or disables automatic links. */ 'auto-links' : true, /** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */ 'light' : false, 'html-script' : false }, config : { space : '&nbsp;', /** Enables use of tags. */ useScriptTags : true, /** Blogger mode flag. */ bloggerMode : false, stripBrs : false, /** Name of the tag that SyntaxHighlighter will automatically look for. */ tagName : 'pre', strings : { expandSource : 'expand source', help : '?', alert: 'SyntaxHighlighter\\n\\n', noBrush : 'Can\\'t find brush for: ', brushNotHtmlScript : 'Brush wasn\\'t configured for html-script option: ', // this is populated by the build script aboutDialog : 'About SyntaxHighlighterSyntaxHighlighterversion 3.0.83 (July 02 2010)http://alexgorbatchev.com/SyntaxHighlighterJavaScript code syntax highlighter.Copyright 2004-2010 Alex Gorbatchev.If you like this script, please donate to keep development active!' } }, /** Internal 'global' variables. */ vars : { discoveredBrushes : null, highlighters : {} }, /** This object is populated by user included external brush files. */ brushes : {}, /** Common regular expressions. */ regexLib : { multiLineCComments : /\\/\\*[\\s\\S]*?\\*\\//gm, singleLineCComments : /\\/\\/.*$/gm, singleLinePerlComments : /#.*$/gm, doubleQuotedString : /\"([^\\\\\"\\n]|\\\\.)*\"/g, singleQuotedString : /'([^\\\\'\\n]|\\\\.)*'/g, multiLineDoubleQuotedString : new XRegExp('\"([^\\\\\\\\\"]|\\\\\\\\.)*\"', 'gs'), multiLineSingleQuotedString : new XRegExp(\"'([^\\\\\\\\']|\\\\\\\\.)*'\", 'gs'), xmlComments : /(&lt;|)/gm, url : /\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g, /** tags. */ phpScriptTags : { left: /(&lt;|)/g }, /** tags. */ aspScriptTags : { left: /(&lt;|)/g }, /** tags. */ scriptScriptTags : { left: /(&lt;|)/gi, right: /(&lt;|)/gi } }, toolbar: { /** * Generates HTML markup for the toolbar. * @param {Highlighter} highlighter Highlighter instance. * @return {String} Returns HTML markup. */ getHtml: function(highlighter) { var html = '', items = sh.toolbar.items, list = items.list ; function defaultGetHtml(highlighter, name) { return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]); }; for (var i = 0; i < list.length; i++) html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]); html += ''; return html; }, /** * Generates HTML markup for a regular button in the toolbar. * @param {Highlighter} highlighter Highlighter instance. * @param {String} commandName Command name that would be executed. * @param {String} label Label text to display. * @return {String} Returns HTML markup. */ getButtonHtml: function(highlighter, commandName, label) { return '' + label + '' ; }, /** * Event handler for a toolbar anchor. */ handler: function(e) { var target = e.target, className = target.className || '' ; function getValue(name) { var r = new RegExp(name + '_(\\\\w+)'), match = r.exec(className) ; return match ? match[1] : null; }; var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id), commandName = getValue('command') ; // execute the toolbar command if (highlighter && commandName) sh.toolbar.items[commandName].execute(highlighter); // disable default A click behaviour e.preventDefault(); }, /** Collection of toolbar items. */ items : { // Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent. list: ['expandSource', 'help'], expandSource: { getHtml: function(highlighter) { if (highlighter.getParam('collapse') != true) return ''; var title = highlighter.getParam('title'); return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource); }, execute: function(highlighter) { var div = getHighlighterDivById(highlighter.id); removeClass(div, 'collapsed'); } }, /** Command to display the about dialog window. */ help: { execute: function(highlighter) { var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'), doc = wnd.document ; doc.write(sh.config.strings.aboutDialog); doc.close(); wnd.focus(); } } } }, /** * Finds all elements on the page which should be processes by SyntaxHighlighter. * * @param {Object} globalParams Optional parameters which override element's * parameters. Only used if element is specified. * * @param {Object} element Optional element to highlight. If none is * provided, all elements in the current document * are returned which qualify. * * @return {Array} Returns list of { target: DOMElement, params: Object } objects. */ findElements: function(globalParams, element) { var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), conf = sh.config, result = [] ; // support for feature if (conf.useScriptTags) elements = elements.concat(getSyntaxHighlighterScriptTags()); if (elements.length === 0) return result; for (var i = 0; i < elements.length; i++) { var item = { target: elements[i], // local params take precedence over globals params: merge(globalParams, parseParams(elements[i].className)) }; if (item.params['brush'] == null) continue; result.push(item); } return result; }, /** * Shorthand to highlight all elements on the page that are marked as * SyntaxHighlighter source code. * * @param {Object} globalParams Optional parameters which override element's * parameters. Only used if element is specified. * * @param {Object} element Optional element to highlight. If none is * provided, all elements in the current document * are highlighted. */ highlight: function(globalParams, element) { var elements = this.findElements(globalParams, element), propertyName = 'innerHTML', highlighter = null, conf = sh.config ; if (elements.length === 0) return; for (var i = 0; i < elements.length; i++) { var element = elements[i], target = element.target, params = element.params, brushName = params.brush, code ; if (brushName == null) continue; // Instantiate a brush if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) { highlighter = new sh.HtmlScript(brushName); brushName = 'htmlscript'; } else { var brush = findBrush(brushName); if (brush) highlighter = new brush(); else continue; } code = target[propertyName]; // remove CDATA from tags if it's present if (conf.useScriptTags) code = stripCData(code); // Inject title if the attribute is present if ((target.title || '') != '') params.title = target.title; params['brush'] = brushName; highlighter.init(params); element = highlighter.getDiv(code); // carry over ID if ((target.id || '') != '') element.id = target.id; target.parentNode.replaceChild(element, target); } }, /** * Main entry point for the SyntaxHighlighter. * @param {Object} params Optional params to apply to all highlighted elements. */ all: function(params) { attachEvent( window, 'load', function() { sh.highlight(params); } ); } }; // end of sh sh['all'] = sh.all; sh['highlight'] = sh.highlight; /** * Checks if target DOM elements has specified CSS class. * @param {DOMElement} target Target DOM element to check. * @param {String} className Name of the CSS class to check for. * @return {Boolean} Returns true if class name is present, false otherwise. */ function hasClass(target, className) { return target.className.indexOf(className) != -1; }; /** * Adds CSS class name to the target DOM element. * @param {DOMElement} target Target DOM element. * @param {String} className New CSS class to add. */ function addClass(target, className) { if (!hasClass(target, className)) target.className += ' ' + className; }; /** * Removes CSS class name from the target DOM element. * @param {DOMElement} target Target DOM element. * @param {String} className CSS class to remove. */ function removeClass(target, className) { target.className = target.className.replace(className, ''); }; /** * Converts the source to array object. Mostly used for function arguments and * lists returned by getElementsByTagName() which aren't Array objects. * @param {List} source Source list. * @return {Array} Returns array. */ function toArray(source) { var result = []; for (var i = 0; i < source.length; i++) result.push(source[i]); return result; }; /** * Splits block of text into lines. * @param {String} block Block of text. * @return {Array} Returns array of lines. */ function splitLines(block) { return block.split('\\n'); } /** * Generates HTML ID for the highlighter. * @param {String} highlighterId Highlighter ID. * @return {String} Returns HTML ID. */ function getHighlighterId(id) { var prefix = 'highlighter_'; return id.indexOf(prefix) == 0 ? id : prefix + id; }; /** * Finds Highlighter instance by ID. * @param {String} highlighterId Highlighter ID. * @return {Highlighter} Returns instance of the highlighter. */ function getHighlighterById(id) { return sh.vars.highlighters[getHighlighterId(id)]; }; /** * Finds highlighter's DIV container. * @param {String} highlighterId Highlighter ID. * @return {Element} Returns highlighter's DIV element. */ function getHighlighterDivById(id) { return document.getElementById(getHighlighterId(id)); }; /** * Stores highlighter so that getHighlighterById() can do its thing. Each * highlighter must call this method to preserve itself. * @param {Highilghter} highlighter Highlighter instance. */ function storeHighlighter(highlighter) { sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter; }; /** * Looks for a child or parent node which has specified classname. * Equivalent to jQuery's $(container).find(\".className\") * @param {Element} target Target element. * @param {String} search Class name or node name to look for. * @param {Boolean} reverse If set to true, will go up the node tree instead of down. * @return {Element} Returns found child or parent element on null. */ function findElement(target, search, reverse /* optional */) { if (target == null) return null; var nodes = reverse != true ? target.childNodes : [ target.parentNode ], propertyToFind = { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName', expectedValue, found ; expectedValue = propertyToFind != 'nodeName' ? search.substr(1) : search.toUpperCase() ; // main return of the found node if ((target[propertyToFind] || '').indexOf(expectedValue) != -1) return target; for (var i = 0; nodes && i < nodes.length && found == null; i++) found = findElement(nodes[i], search, reverse); return found; }; /** * Looks for a parent node which has specified classname. * This is an alias to findElement(container, className, true). * @param {Element} target Target element. * @param {String} className Class name to look for. * @return {Element} Returns found parent element on null. */ function findParentElement(target, className) { return findElement(target, className, true); }; /** * Finds an index of element in the array. * @ignore * @param {Object} searchElement * @param {Number} fromIndex * @return {Number} Returns index of element if found; -1 otherwise. */ function indexOf(array, searchElement, fromIndex) { fromIndex = Math.max(fromIndex || 0, 0); for (var i = fromIndex; i < array.length; i++) if(array[i] == searchElement) return i; return -1; }; /** * Generates a unique element ID. */ function guid(prefix) { return (prefix || '') + Math.round(Math.random() * 1000000).toString(); }; /** * Merges two objects. Values from obj2 override values in obj1. * Function is NOT recursive and works only for one dimensional objects. * @param {Object} obj1 First object. * @param {Object} obj2 Second object. * @return {Object} Returns combination of both objects. */ function merge(obj1, obj2) { var result = {}, name; for (name in obj1) result[name] = obj1[name]; for (name in obj2) result[name] = obj2[name]; return result; }; /** * Attempts to convert string to boolean. * @param {String} value Input string. * @return {Boolean} Returns true if input was \"true\", false if input was \"false\" and value otherwise. */ function toBoolean(value) { var result = { \"true\" : true, \"false\" : false }[value]; return result == null ? value : result; }; /** * Opens up a centered popup window. * @param {String} url URL to open in the window. * @param {String} name Popup name. * @param {int} width Popup width. * @param {int} height Popup height. * @param {String} options window.open() options. * @return {Window} Returns window instance. */ function popup(url, name, width, height, options) { var x = (screen.width - width) / 2, y = (screen.height - height) / 2 ; options += ', left=' + x + ', top=' + y + ', width=' + width + ', height=' + height ; options = options.replace(/^,/, ''); var win = window.open(url, name, options); win.focus(); return win; }; /** * Adds event handler to the target object. * @param {Object} obj Target object. * @param {String} type Name of the event. * @param {Function} func Handling function. */ function attachEvent(obj, type, func, scope) { function handler(e) { e = e || window.event; if (!e.target) { e.target = e.srcElement; e.preventDefault = function() { this.returnValue = false; }; } func.call(scope || window, e); }; if (obj.attachEvent) { obj.attachEvent('on' + type, handler); } else { obj.addEventListener(type, handler, false); } }; /** * Displays an alert. * @param {String} str String to display. */ function alert(str) { window.alert(sh.config.strings.alert + str); }; /** * Finds a brush by its alias. * * @param {String} alias Brush alias. * @param {Boolean} showAlert Suppresses the alert if false. * @return {Brush} Returns bursh constructor if found, null otherwise. */ function findBrush(alias, showAlert) { var brushes = sh.vars.discoveredBrushes, result = null ; if (brushes == null) { brushes = {}; // Find all brushes for (var brush in sh.brushes) { var info = sh.brushes[brush], aliases = info.aliases ; if (aliases == null) continue; // keep the brush name info.brushName = brush.toLowerCase(); for (var i = 0; i < aliases.length; i++) brushes[aliases[i]] = brush; } sh.vars.discoveredBrushes = brushes; } result = sh.brushes[brushes[alias]]; if (result == null && showAlert != false) alert(sh.config.strings.noBrush + alias); return result; }; /** * Executes a callback on each line and replaces each line with result from the callback. * @param {Object} str Input string. * @param {Object} callback Callback function taking one string argument and returning a string. */ function eachLine(str, callback) { var lines = splitLines(str); for (var i = 0; i < lines.length; i++) lines[i] = callback(lines[i], i); return lines.join('\\n'); }; /** * This is a special trim which only removes first and last empty lines * and doesn't affect valid leading space on the first line. * * @param {String} str Input string * @return {String} Returns string without empty first and last lines. */ function trimFirstAndLastLines(str) { return str.replace(/^[ ]*[\\n]+|[\\n]*[ ]*$/g, ''); }; /** * Parses key/value pairs into hash object. * * Understands the following formats: * - name: word; * - name: [word, word]; * - name: \"string\"; * - name: 'string'; * * For example: * name1: value; name2: [value, value]; name3: 'value' * * @param {String} str Input string. * @return {Object} Returns deserialized object. */ function parseParams(str) { var match, result = {}, arrayRegex = new XRegExp(\"^\\\\[(?(.*?))\\\\]$\"), regex = new XRegExp( \"(?[\\\\w-]+)\" + \"\\\\s*:\\\\s*\" + \"(?\" + \"[\\\\w-%#]+|\" + // word \"\\\\[.*?\\\\]|\" + // [] array '\".*?\"|' + // \"\" string \"'.*?'\" + // '' string \")\\\\s*;?\", \"g\" ) ; while ((match = regex.exec(str)) != null) { var value = match.value .replace(/^['\"]|['\"]$/g, '') // strip quotes from end of strings ; // try to parse array value if (value != null && arrayRegex.test(value)) { var m = arrayRegex.exec(value); value = m.values.length > 0 ? m.values.split(/\\s*,\\s*/) : []; } result[match.name] = value; } return result; }; /** * Wraps each line of the string into tag with given style applied to it. * * @param {String} str Input string. * @param {String} css Style name to apply to the string. * @return {String} Returns input string with each line surrounded by tag. */ function wrapLinesWithCode(str, css) { if (str == null || str.length == 0 || str == '\\n') return str; str = str.replace(/"},{"title":"","date":"2020-10-15T20:13:29.153Z","updated":"2019-04-27T04:08:33.584Z","comments":true,"path":"js/jquery-1.4.2.js","permalink":"https://knowledge.capitaltwo.ga/js/jquery-1.4.2.js","excerpt":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function( window, undefined ) { // Define a local copy of jQuery var jQuery = function( selector, context ) { // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context ); }, // Map over jQuery in case of overwrite _jQuery = window.jQuery, // Map over the $ in case of overwrite _$ = window.$, // Use the correct document accordingly with window argument (sandbox) document = window.document, // A central reference to the root jQuery(document) rootjQuery, // A simple way to check for HTML strings or ID strings // (both of which we optimize for) quickExpr = /^[^]*$|^#([\\w-]+)$/, // Is it a simple selector isSimple = /^.[^:#\\[\\.,]*$/, // Check if a string has a non-whitespace character in it rnotwhite = /\\S/, // Used for trimming whitespace rtrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g, // Match a standalone tag rsingleTag = /^(?:)?$/, // Keep a UserAgent string for use with jQuery.browser userAgent = navigator.userAgent, // For matching the engine and version of the browser browserMatch, // Has the ready events already been bound? readyBound = false, // The functions to execute on DOM ready readyList = [], // The ready event handler DOMContentLoaded, // Save a reference to some core methods toString = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, push = Array.prototype.push, slice = Array.prototype.slice, indexOf = Array.prototype.indexOf; jQuery.fn = jQuery.prototype = { init: function( selector, context ) { var match, elem, ret, doc; // Handle $(\"\"), $(null), or $(undefined) if ( !selector ) { return this; } // Handle $(DOMElement) if ( selector.nodeType ) { this.context = this[0] = selector; this.length = 1; return this; } // The body element only exists once, optimize finding it if ( selector === \"body\" && !context ) { this.context = document; this[0] = document.body; this.selector = \"body\"; this.length = 1; return this; } // Handle HTML strings if ( typeof selector === \"string\" ) { // Are we dealing with HTML string or an ID? match = quickExpr.exec( selector ); // Verify a match, and that no context was specified for #id if ( match && (match[1] || !context) ) { // HANDLE: $(html) -> $(array) if ( match[1] ) { doc = (context ? context.ownerDocument || context : document); // If a single string is passed in and it's a single tag // just do a createElement and skip the rest ret = rsingleTag.exec( selector ); if ( ret ) { if ( jQuery.isPlainObject( context ) ) { selector = [ document.createElement( ret[1] ) ]; jQuery.fn.attr.call( selector, context, true ); } else { selector = [ doc.createElement( ret[1] ) ]; } } else { ret = buildFragment( [ match[1] ], [ doc ] ); selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes; } return jQuery.merge( this, selector ); // HANDLE: $(\"#id\") } else { elem = document.getElementById( match[2] ); if ( elem ) { // Handle the case where IE and Opera return items // by name instead of ID if ( elem.id !== match[2] ) { return rootjQuery.find( selector ); } // Otherwise, we inject the element directly into the jQuery object this.length = 1; this[0] = elem; } this.context = document; this.selector = selector; return this; } // HANDLE: $(\"TAG\") } else if ( !context && /^\\w+$/.test( selector ) ) { this.selector = selector; this.context = document; selector = document.getElementsByTagName( selector ); return jQuery.merge( this, selector ); // HANDLE: $(expr, $(...)) } else if ( !context || context.jquery ) { return (context || rootjQuery).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) } else { return jQuery( context ).find( selector ); } // HANDLE: $(function) // Shortcut for document ready } else if ( jQuery.isFunction( selector ) ) { return rootjQuery.ready( selector ); } if (selector.selector !== undefined) { this.selector = selector.selector; this.context = selector.context; } return jQuery.makeArray( selector, this ); }, // Start with an empty selector selector: \"\", // The current version of jQuery being used jquery: \"1.4.2\", // The default length of a jQuery object is 0 length: 0, // The number of elements contained in the matched element set size: function() { return this.length; }, toArray: function() { return slice.call( this, 0 ); }, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function( num ) { return num == null ? // Return a 'clean' array this.toArray() : // Return just the object ( num < 0 ? this.slice(num)[ 0 ] : this[ num ] ); }, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function( elems, name, selector ) { // Build a new jQuery matched element set var ret = jQuery(); if ( jQuery.isArray( elems ) ) { push.apply( ret, elems ); } else { jQuery.merge( ret, elems ); } // Add the old object onto the stack (as a reference) ret.prevObject = this; ret.context = this.context; if ( name === \"find\" ) { ret.selector = this.selector + (this.selector ? \" \" : \"\") + selector; } else if ( name ) { ret.selector = this.selector + \".\" + name + \"(\" + selector + \")\"; } // Return the newly-formed element set return ret; }, // Execute a callback for every element in the matched set. // (You can seed the arguments with an array of args, but this is // only used internally.) each: function( callback, args ) { return jQuery.each( this, callback, args ); }, ready: function( fn ) { // Attach the listeners jQuery.bindReady(); // If the DOM is already ready if ( jQuery.isReady ) { // Execute the function immediately fn.call( document, jQuery ); // Otherwise, remember the function for later } else if ( readyList ) { // Add the function to the wait list readyList.push( fn ); } return this; }, eq: function( i ) { return i === -1 ? this.slice( i ) : this.slice( i, +i + 1 ); }, first: function() { return this.eq( 0 ); }, last: function() { return this.eq( -1 ); }, slice: function() { return this.pushStack( slice.apply( this, arguments ), \"slice\", slice.call(arguments).join(\",\") ); }, map: function( callback ) { return this.pushStack( jQuery.map(this, function( elem, i ) { return callback.call( elem, i, elem ); })); }, end: function() { return this.prevObject || jQuery(null); }, // For internal use only. // Behaves like an Array's method, not like a jQuery method. push: push, sort: [].sort, splice: [].splice }; // Give the init function the jQuery prototype for later instantiation jQuery.fn.init.prototype = jQuery.fn; jQuery.extend = jQuery.fn.extend = function() { // copy reference to target object var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy; // Handle a deep copy situation if ( typeof target === \"boolean\" ) { deep = target; target = arguments[1] || {}; // skip the boolean and the target i = 2; } // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) { target = {}; } // extend jQuery itself if only one argument is passed if ( length === i ) { target = this; --i; } for ( ; i < length; i++ ) { // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) { // Extend the base object for ( name in options ) { src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) { continue; } // Recurse if we're merging object literal values or arrays if ( deep && copy && ( jQuery.isPlainObject(copy) || jQuery.isArray(copy) ) ) { var clone = src && ( jQuery.isPlainObject(src) || jQuery.isArray(src) ) ? src : jQuery.isArray(copy) ? [] : {}; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values } else if ( copy !== undefined ) { target[ name ] = copy; } } } } // Return the modified object return target; }; jQuery.extend({ noConflict: function( deep ) { window.$ = _$; if ( deep ) { window.jQuery = _jQuery; } return jQuery; }, // Is the DOM ready to be used? Set to true once it occurs. isReady: false, // Handle when the DOM is ready ready: function() { // Make sure that the DOM is not already loaded if ( !jQuery.isReady ) { // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443). if ( !document.body ) { return setTimeout( jQuery.ready, 13 ); } // Remember that the DOM is ready jQuery.isReady = true; // If there are functions bound, to execute if ( readyList ) { // Execute all of them var fn, i = 0; while ( (fn = readyList[ i++ ]) ) { fn.call( document, jQuery ); } // Reset the list of functions readyList = null; } // Trigger any bound ready events if ( jQuery.fn.triggerHandler ) { jQuery( document ).triggerHandler( \"ready\" ); } } }, bindReady: function() { if ( readyBound ) { return; } readyBound = true; // Catch cases where $(document).ready() is called after the // browser event has already occurred. if ( document.readyState === \"complete\" ) { return jQuery.ready(); } // Mozilla, Opera and webkit nightlies currently support this event if ( document.addEventListener ) { // Use the handy event callback document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false ); // A fallback to window.onload, that will always work window.addEventListener( \"load\", jQuery.ready, false ); // If IE event model is used } else if ( document.attachEvent ) { // ensure firing before onload, // maybe late but safe also for iframes document.attachEvent(\"onreadystatechange\", DOMContentLoaded); // A fallback to window.onload, that will always work window.attachEvent( \"onload\", jQuery.ready ); // If IE and not a frame // continually check to see if the document is ready var toplevel = false; try { toplevel = window.frameElement == null; } catch(e) {} if ( document.documentElement.doScroll && toplevel ) { doScrollCheck(); } } }, // See test/unit/core.js for details concerning isFunction. // Since version 1.3, DOM methods and functions like alert // aren't supported. They return false on IE (#2968). isFunction: function( obj ) { return toString.call(obj) === \"[object Function]\"; }, isArray: function( obj ) { return toString.call(obj) === \"[object Array]\"; }, isPlainObject: function( obj ) { // Must be an Object. // Because of IE, we also have to check the presence of the constructor property. // Make sure that DOM nodes and window objects don't pass through, as well if ( !obj || toString.call(obj) !== \"[object Object]\" || obj.nodeType || obj.setInterval ) { return false; } // Not own constructor property must be Object if ( obj.constructor && !hasOwnProperty.call(obj, \"constructor\") && !hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\") ) { return false; } // Own properties are enumerated firstly, so to speed up, // if last one is own, then all properties are own. var key; for ( key in obj ) {} return key === undefined || hasOwnProperty.call( obj, key ); }, isEmptyObject: function( obj ) { for ( var name in obj ) { return false; } return true; }, error: function( msg ) { throw msg; }, parseJSON: function( data ) { if ( typeof data !== \"string\" || !data ) { return null; } // Make sure leading/trailing whitespace is removed (IE can't handle it) data = jQuery.trim( data ); // Make sure the incoming data is actual JSON // Logic borrowed from http://json.org/json2.js if ( /^[\\],:{}\\s]*$/.test(data.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\") .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\") .replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\")) ) { // Try to use the native JSON parser first return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function(\"return \" + data))(); } else { jQuery.error( \"Invalid JSON: \" + data ); } }, noop: function() {}, // Evalulates a script in a global context globalEval: function( data ) { if ( data && rnotwhite.test(data) ) { // Inspired by code by Andrea Giammarchi // http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html var head = document.getElementsByTagName(\"head\")[0] || document.documentElement, script = document.createElement(\"script\"); script.type = \"text/javascript\"; if ( jQuery.support.scriptEval ) { script.appendChild( document.createTextNode( data ) ); } else { script.text = data; } // Use insertBefore instead of appendChild to circumvent an IE6 bug. // This arises when a base node is used (#2709). head.insertBefore( script, head.firstChild ); head.removeChild( script ); } }, nodeName: function( elem, name ) { return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase(); }, // args is for internal usage only each: function( object, callback, args ) { var name, i = 0, length = object.length, isObj = length === undefined || jQuery.isFunction(object); if ( args ) { if ( isObj ) { for ( name in object ) { if ( callback.apply( object[ name ], args ) === false ) { break; } } } else { for ( ; i < length; ) { if ( callback.apply( object[ i++ ], args ) === false ) { break; } } } // A special, fast, case for the most common use of each } else { if ( isObj ) { for ( name in object ) { if ( callback.call( object[ name ], name, object[ name ] ) === false ) { break; } } } else { for ( var value = object[0]; i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {} } } return object; }, trim: function( text ) { return (text || \"\").replace( rtrim, \"\" ); }, // results is for internal usage only makeArray: function( array, results ) { var ret = results || []; if ( array != null ) { // The window, strings (and functions) also have 'length' // The extra typeof function check is to prevent crashes // in Safari 2 (See: #3039) if ( array.length == null || typeof array === \"string\" || jQuery.isFunction(array) || (typeof array !== \"function\" && array.setInterval) ) { push.call( ret, array ); } else { jQuery.merge( ret, array ); } } return ret; }, inArray: function( elem, array ) { if ( array.indexOf ) { return array.indexOf( elem ); } for ( var i = 0, length = array.length; i < length; i++ ) { if ( array[ i ] === elem ) { return i; } } return -1; }, merge: function( first, second ) { var i = first.length, j = 0; if ( typeof second.length === \"number\" ) { for ( var l = second.length; j < l; j++ ) { first[ i++ ] = second[ j ]; } } else { while ( second[j] !== undefined ) { first[ i++ ] = second[ j++ ]; } } first.length = i; return first; }, grep: function( elems, callback, inv ) { var ret = []; // Go through the array, only saving the items // that pass the validator function for ( var i = 0, length = elems.length; i < length; i++ ) { if ( !inv !== !callback( elems[ i ], i ) ) { ret.push( elems[ i ] ); } } return ret; }, // arg is for internal usage only map: function( elems, callback, arg ) { var ret = [], value; // Go through the array, translating each of the items to their // new value (or values). for ( var i = 0, length = elems.length; i < length; i++ ) { value = callback( elems[ i ], i, arg ); if ( value != null ) { ret[ ret.length ] = value; } } return ret.concat.apply( [], ret ); }, // A global GUID counter for objects guid: 1, proxy: function( fn, proxy, thisObject ) { if ( arguments.length === 2 ) { if ( typeof proxy === \"string\" ) { thisObject = fn; fn = thisObject[ proxy ]; proxy = undefined; } else if ( proxy && !jQuery.isFunction( proxy ) ) { thisObject = proxy; proxy = undefined; } } if ( !proxy && fn ) { proxy = function() { return fn.apply( thisObject || this, arguments ); }; } // Set the guid of unique handler to the same of original handler, so it can be removed if ( fn ) { proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++; } // So proxy can be declared as an argument return proxy; }, // Use of jQuery.browser is frowned upon. // More details: http://docs.jquery.com/Utilities/jQuery.browser uaMatch: function( ua ) { ua = ua.toLowerCase(); var match = /(webkit)[ \\/]([\\w.]+)/.exec( ua ) || /(opera)(?:.*version)?[ \\/]([\\w.]+)/.exec( ua ) || /(msie) ([\\w.]+)/.exec( ua ) || !/compatible/.test( ua ) && /(mozilla)(?:.*? rv:([\\w.]+))?/.exec( ua ) || []; return { browser: match[1] || \"\", version: match[2] || \"0\" }; }, browser: {} }); browserMatch = jQuery.uaMatch( userAgent ); if ( browserMatch.browser ) { jQuery.browser[ browserMatch.browser ] = true; jQuery.browser.version = browserMatch.version; } // Deprecated, use jQuery.browser.webkit instead if ( jQuery.browser.webkit ) { jQuery.browser.safari = true; } if ( indexOf ) { jQuery.inArray = function( elem, array ) { return indexOf.call( array, elem ); }; } // All jQuery objects should point back to these rootjQuery = jQuery(document); // Cleanup functions for the document ready method if ( document.addEventListener ) { DOMContentLoaded = function() { document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false ); jQuery.ready(); }; } else if ( document.attachEvent ) { DOMContentLoaded = function() { // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443). if ( document.readyState === \"complete\" ) { document.detachEvent( \"onreadystatechange\", DOMContentLoaded ); jQuery.ready(); } }; } // The DOM ready check for Internet Explorer function doScrollCheck() { if ( jQuery.isReady ) { return; } try { // If IE is used, use the trick by Diego Perini // http://javascript.nwbox.com/IEContentLoaded/ document.documentElement.doScroll(\"left\"); } catch( error ) { setTimeout( doScrollCheck, 1 ); return; } // and execute any waiting functions jQuery.ready(); } function evalScript( i, elem ) { if ( elem.src ) { jQuery.ajax({ url: elem.src, async: false, dataType: \"script\" }); } else { jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" ); } if ( elem.parentNode ) { elem.parentNode.removeChild( elem ); } } // Mutifunctional method to get and set values to a collection // The value/s can be optionally by executed if its a function function access( elems, key, value, exec, fn, pass ) { var length = elems.length; // Setting many attributes if ( typeof key === \"object\" ) { for ( var k in key ) { access( elems, k, key[k], exec, fn, value ); } return elems; } // Setting one attribute if ( value !== undefined ) { // Optionally, function values get executed if exec is true exec = !pass && exec && jQuery.isFunction(value); for ( var i = 0; i < length; i++ ) { fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass ); } return elems; } // Getting an attribute return length ? fn( elems[0], key ) : undefined; } function now() { return (new Date).getTime(); } (function() { jQuery.support = {}; var root = document.documentElement, script = document.createElement(\"script\"), div = document.createElement(\"div\"), id = \"script\" + now(); div.style.display = \"none\"; div.innerHTML = \" a\"; var all = div.getElementsByTagName(\"*\"), a = div.getElementsByTagName(\"a\")[0]; // Can't get basic test support if ( !all || !all.length || !a ) { return; } jQuery.support = { // IE strips leading whitespace when .innerHTML is used leadingWhitespace: div.firstChild.nodeType === 3, // Make sure that tbody elements aren't automatically inserted // IE will insert them into empty tables tbody: !div.getElementsByTagName(\"tbody\").length, // Make sure that link elements get serialized correctly by innerHTML // This requires a wrapper element in IE htmlSerialize: !!div.getElementsByTagName(\"link\").length, // Get the style information from getAttribute // (IE uses .cssText insted) style: /red/.test( a.getAttribute(\"style\") ), // Make sure that URLs aren't manipulated // (IE normalizes it by default) hrefNormalized: a.getAttribute(\"href\") === \"/a\", // Make sure that element opacity exists // (IE uses filter instead) // Use a regex to work around a WebKit issue. See #5145 opacity: /^0.55$/.test( a.style.opacity ), // Verify style float existence // (IE uses styleFloat instead of cssFloat) cssFloat: !!a.style.cssFloat, // Make sure that if no value is specified for a checkbox // that it defaults to \"on\". // (WebKit defaults to \"\" instead) checkOn: div.getElementsByTagName(\"input\")[0].value === \"on\", // Make sure that a selected-by-default option has a working selected property. // (WebKit defaults to false instead of true, IE too, if it's in an optgroup) optSelected: document.createElement(\"select\").appendChild( document.createElement(\"option\") ).selected, parentNode: div.removeChild( div.appendChild( document.createElement(\"div\") ) ).parentNode === null, // Will be defined later deleteExpando: true, checkClone: false, scriptEval: false, noCloneEvent: true, boxModel: null }; script.type = \"text/javascript\"; try { script.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) ); } catch(e) {} root.insertBefore( script, root.firstChild ); // Make sure that the execution of code works by injecting a script // tag with appendChild/createTextNode // (IE doesn't support this, fails, and uses .text instead) if ( window[ id ] ) { jQuery.support.scriptEval = true; delete window[ id ]; } // Test to see if it's possible to delete an expando from an element // Fails in Internet Explorer try { delete script.test; } catch(e) { jQuery.support.deleteExpando = false; } root.removeChild( script ); if ( div.attachEvent && div.fireEvent ) { div.attachEvent(\"onclick\", function click() { // Cloning a node shouldn't copy over any // bound event handlers (IE does this) jQuery.support.noCloneEvent = false; div.detachEvent(\"onclick\", click); }); div.cloneNode(true).fireEvent(\"onclick\"); } div = document.createElement(\"div\"); div.innerHTML = \"\"; var fragment = document.createDocumentFragment(); fragment.appendChild( div.firstChild ); // WebKit doesn't clone checked state correctly in fragments jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Figure out if the W3C box model works as expected // document.body must exist before we can do this jQuery(function() { var div = document.createElement(\"div\"); div.style.width = div.style.paddingLeft = \"1px\"; document.body.appendChild( div ); jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2; document.body.removeChild( div ).style.display = 'none'; div = null; }); // Technique from Juriy Zaytsev // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/ var eventSupported = function( eventName ) { var el = document.createElement(\"div\"); eventName = \"on\" + eventName; var isSupported = (eventName in el); if ( !isSupported ) { el.setAttribute(eventName, \"return;\"); isSupported = typeof el[eventName] === \"function\"; } el = null; return isSupported; }; jQuery.support.submitBubbles = eventSupported(\"submit\"); jQuery.support.changeBubbles = eventSupported(\"change\"); // release memory in IE root = script = div = all = a = null; })(); jQuery.props = { \"for\": \"htmlFor\", \"class\": \"className\", readonly: \"readOnly\", maxlength: \"maxLength\", cellspacing: \"cellSpacing\", rowspan: \"rowSpan\", colspan: \"colSpan\", tabindex: \"tabIndex\", usemap: \"useMap\", frameborder: \"frameBorder\" }; var expando = \"jQuery\" + now(), uuid = 0, windowData = {}; jQuery.extend({ cache: {}, expando:expando, // The following elements throw uncatchable exceptions if you // attempt to add expando properties to them. noData: { \"embed\": true, \"object\": true, \"applet\": true }, data: function( elem, name, data ) { if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) { return; } elem = elem == window ? windowData : elem; var id = elem[ expando ], cache = jQuery.cache, thisCache; if ( !id && typeof name === \"string\" && data === undefined ) { return null; } // Compute a unique ID for the element if ( !id ) { id = ++uuid; } // Avoid generating a new cache unless none exists and we // want to manipulate it. if ( typeof name === \"object\" ) { elem[ expando ] = id; thisCache = cache[ id ] = jQuery.extend(true, {}, name); } else if ( !cache[ id ] ) { elem[ expando ] = id; cache[ id ] = {}; } thisCache = cache[ id ]; // Prevent overriding the named cache with undefined values if ( data !== undefined ) { thisCache[ name ] = data; } return typeof name === \"string\" ? thisCache[ name ] : thisCache; }, removeData: function( elem, name ) { if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) { return; } elem = elem == window ? windowData : elem; var id = elem[ expando ], cache = jQuery.cache, thisCache = cache[ id ]; // If we want to remove a specific section of the element's data if ( name ) { if ( thisCache ) { // Remove the section of cache data delete thisCache[ name ]; // If we've removed all the data, remove the element's cache if ( jQuery.isEmptyObject(thisCache) ) { jQuery.removeData( elem ); } } // Otherwise, we want to remove all of the element's data } else { if ( jQuery.support.deleteExpando ) { delete elem[ jQuery.expando ]; } else if ( elem.removeAttribute ) { elem.removeAttribute( jQuery.expando ); } // Completely remove the data cache delete cache[ id ]; } } }); jQuery.fn.extend({ data: function( key, value ) { if ( typeof key === \"undefined\" && this.length ) { return jQuery.data( this[0] ); } else if ( typeof key === \"object\" ) { return this.each(function() { jQuery.data( this, key ); }); } var parts = key.split(\".\"); parts[1] = parts[1] ? \".\" + parts[1] : \"\"; if ( value === undefined ) { var data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]); if ( data === undefined && this.length ) { data = jQuery.data( this[0], key ); } return data === undefined && parts[1] ? this.data( parts[0] ) : data; } else { return this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function() { jQuery.data( this, key, value ); }); } }, removeData: function( key ) { return this.each(function() { jQuery.removeData( this, key ); }); } }); jQuery.extend({ queue: function( elem, type, data ) { if ( !elem ) { return; } type = (type || \"fx\") + \"queue\"; var q = jQuery.data( elem, type ); // Speed up dequeue by getting out quickly if this is just a lookup if ( !data ) { return q || []; } if ( !q || jQuery.isArray(data) ) { q = jQuery.data( elem, type, jQuery.makeArray(data) ); } else { q.push( data ); } return q; }, dequeue: function( elem, type ) { type = type || \"fx\"; var queue = jQuery.queue( elem, type ), fn = queue.shift(); // If the fx queue is dequeued, always remove the progress sentinel if ( fn === \"inprogress\" ) { fn = queue.shift(); } if ( fn ) { // Add a progress sentinel to prevent the fx queue from being // automatically dequeued if ( type === \"fx\" ) { queue.unshift(\"inprogress\"); } fn.call(elem, function() { jQuery.dequeue(elem, type); }); } } }); jQuery.fn.extend({ queue: function( type, data ) { if ( typeof type !== \"string\" ) { data = type; type = \"fx\"; } if ( data === undefined ) { return jQuery.queue( this[0], type ); } return this.each(function( i, elem ) { var queue = jQuery.queue( this, type, data ); if ( type === \"fx\" && queue[0] !== \"inprogress\" ) { jQuery.dequeue( this, type ); } }); }, dequeue: function( type ) { return this.each(function() { jQuery.dequeue( this, type ); }); }, // Based off of the plugin by Clint Helfers, with permission. // http://blindsignals.com/index.php/2009/07/jquery-delay/ delay: function( time, type ) { time = jQuery.fx ? jQuery.fx.speeds[time] || time : time; type = type || \"fx\"; return this.queue( type, function() { var elem = this; setTimeout(function() { jQuery.dequeue( elem, type ); }, time ); }); }, clearQueue: function( type ) { return this.queue( type || \"fx\", [] ); } }); var rclass = /[\\n\\t]/g, rspace = /\\s+/, rreturn = /\\r/g, rspecialurl = /href|src|style/, rtype = /(button|input)/i, rfocusable = /(button|input|object|select|textarea)/i, rclickable = /^(a|area)$/i, rradiocheck = /radio|checkbox/; jQuery.fn.extend({ attr: function( name, value ) { return access( this, name, value, true, jQuery.attr ); }, removeAttr: function( name, fn ) { return this.each(function(){ jQuery.attr( this, name, \"\" ); if ( this.nodeType === 1 ) { this.removeAttribute( name ); } }); }, addClass: function( value ) { if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); self.addClass( value.call(this, i, self.attr(\"class\")) ); }); } if ( value && typeof value === \"string\" ) { var classNames = (value || \"\").split( rspace ); for ( var i = 0, l = this.length; i < l; i++ ) { var elem = this[i]; if ( elem.nodeType === 1 ) { if ( !elem.className ) { elem.className = value; } else { var className = \" \" + elem.className + \" \", setClass = elem.className; for ( var c = 0, cl = classNames.length; c < cl; c++ ) { if ( className.indexOf( \" \" + classNames[c] + \" \" ) < 0 ) { setClass += \" \" + classNames[c]; } } elem.className = jQuery.trim( setClass ); } } } } return this; }, removeClass: function( value ) { if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); self.removeClass( value.call(this, i, self.attr(\"class\")) ); }); } if ( (value && typeof value === \"string\") || value === undefined ) { var classNames = (value || \"\").split(rspace); for ( var i = 0, l = this.length; i < l; i++ ) { var elem = this[i]; if ( elem.nodeType === 1 && elem.className ) { if ( value ) { var className = (\" \" + elem.className + \" \").replace(rclass, \" \"); for ( var c = 0, cl = classNames.length; c < cl; c++ ) { className = className.replace(\" \" + classNames[c] + \" \", \" \"); } elem.className = jQuery.trim( className ); } else { elem.className = \"\"; } } } } return this; }, toggleClass: function( value, stateVal ) { var type = typeof value, isBool = typeof stateVal === \"boolean\"; if ( jQuery.isFunction( value ) ) { return this.each(function(i) { var self = jQuery(this); self.toggleClass( value.call(this, i, self.attr(\"class\"), stateVal), stateVal ); }); } return this.each(function() { if ( type === \"string\" ) { // toggle individual class names var className, i = 0, self = jQuery(this), state = stateVal, classNames = value.split( rspace ); while ( (className = classNames[ i++ ]) ) { // check each className given, space seperated list state = isBool ? state : !self.hasClass( className ); self[ state ? \"addClass\" : \"removeClass\" ]( className ); } } else if ( type === \"undefined\" || type === \"boolean\" ) { if ( this.className ) { // store className if set jQuery.data( this, \"__className__\", this.className ); } // toggle whole className this.className = this.className || value === false ? \"\" : jQuery.data( this, \"__className__\" ) || \"\"; } }); }, hasClass: function( selector ) { var className = \" \" + selector + \" \"; for ( var i = 0, l = this.length; i < l; i++ ) { if ( (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) { return true; } } return false; }, val: function( value ) { if ( value === undefined ) { var elem = this[0]; if ( elem ) { if ( jQuery.nodeName( elem, \"option\" ) ) { return (elem.attributes.value || {}).specified ? elem.value : elem.text; } // We need to handle select boxes special if ( jQuery.nodeName( elem, \"select\" ) ) { var index = elem.selectedIndex, values = [], options = elem.options, one = elem.type === \"select-one\"; // Nothing was selected if ( index < 0 ) { return null; } // Loop through all the selected options for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) { var option = options[ i ]; if ( option.selected ) { // Get the specifc value for the option value = jQuery(option).val(); // We don't need an array for one selects if ( one ) { return value; } // Multi-Selects return an array values.push( value ); } } return values; } // Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) { return elem.getAttribute(\"value\") === null ? \"on\" : elem.value; } // Everything else, we just grab the value return (elem.value || \"\").replace(rreturn, \"\"); } return undefined; } var isFunction = jQuery.isFunction(value); return this.each(function(i) { var self = jQuery(this), val = value; if ( this.nodeType !== 1 ) { return; } if ( isFunction ) { val = value.call(this, i, self.val()); } // Typecast each time if the value is a Function and the appended // value is therefore different each time. if ( typeof val === \"number\" ) { val += \"\"; } if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) { this.checked = jQuery.inArray( self.val(), val ) >= 0; } else if ( jQuery.nodeName( this, \"select\" ) ) { var values = jQuery.makeArray(val); jQuery( \"option\", this ).each(function() { this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0; }); if ( !values.length ) { this.selectedIndex = -1; } } else { this.value = val; } }); } }); jQuery.extend({ attrFn: { val: true, css: true, html: true, text: true, data: true, width: true, height: true, offset: true }, attr: function( elem, name, value, pass ) { // don't set attributes on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } if ( pass && name in jQuery.attrFn ) { return jQuery(elem)[name](value); } var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ), // Whether we are setting (or getting) set = value !== undefined; // Try to normalize/fix the name name = notxml && jQuery.props[ name ] || name; // Only do all the following if this is a node (faster for style) if ( elem.nodeType === 1 ) { // These attributes require special treatment var special = rspecialurl.test( name ); // Safari mis-reports the default selected property of an option // Accessing the parent's selectedIndex property fixes it if ( name === \"selected\" && !jQuery.support.optSelected ) { var parent = elem.parentNode; if ( parent ) { parent.selectedIndex; // Make sure that it also works with optgroups, see #5701 if ( parent.parentNode ) { parent.parentNode.selectedIndex; } } } // If applicable, access the attribute via the DOM 0 way if ( name in elem && notxml && !special ) { if ( set ) { // We can't allow the type property to be changed (since it causes problems in IE) if ( name === \"type\" && rtype.test( elem.nodeName ) && elem.parentNode ) { jQuery.error( \"type property can't be changed\" ); } elem[ name ] = value; } // browsers index elements by id/name on forms, give priority to attributes. if ( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) ) { return elem.getAttributeNode( name ).nodeValue; } // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ if ( name === \"tabIndex\" ) { var attributeNode = elem.getAttributeNode( \"tabIndex\" ); return attributeNode && attributeNode.specified ? attributeNode.value : rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ? 0 : undefined; } return elem[ name ]; } if ( !jQuery.support.style && notxml && name === \"style\" ) { if ( set ) { elem.style.cssText = \"\" + value; } return elem.style.cssText; } if ( set ) { // convert the value to a string (all browsers do this but IE) see #1070 elem.setAttribute( name, \"\" + value ); } var attr = !jQuery.support.hrefNormalized && notxml && special ? // Some attributes require a special call on IE elem.getAttribute( name, 2 ) : elem.getAttribute( name ); // Non-existent attributes return null, we normalize to undefined return attr === null ? undefined : attr; } // elem is actually elem.style ... set the style // Using attr for specific style information is now deprecated. Use style instead. return jQuery.style( elem, name, value ); } }); var rnamespaces = /\\.(.*)$/, fcleanup = function( nm ) { return nm.replace(/[^\\w\\s\\.\\|`]/g, function( ch ) { return \"\\\\\" + ch; }); }; /* * A number of helper functions used for managing events. * Many of the ideas behind this code originated from * Dean Edwards' addEvent library. */ jQuery.event = { // Bind an event to an element // Original by Dean Edwards add: function( elem, types, handler, data ) { if ( elem.nodeType === 3 || elem.nodeType === 8 ) { return; } // For whatever reason, IE has trouble passing the window object // around, causing it to be cloned in the process if ( elem.setInterval && ( elem !== window && !elem.frameElement ) ) { elem = window; } var handleObjIn, handleObj; if ( handler.handler ) { handleObjIn = handler; handler = handleObjIn.handler; } // Make sure that the function being executed has a unique ID if ( !handler.guid ) { handler.guid = jQuery.guid++; } // Init the element's event structure var elemData = jQuery.data( elem ); // If no elemData is found then we must be trying to bind to one of the // banned noData elements if ( !elemData ) { return; } var events = elemData.events = elemData.events || {}, eventHandle = elemData.handle, eventHandle; if ( !eventHandle ) { elemData.handle = eventHandle = function() { // Handle the second event of a trigger and when // an event is called after a page has unloaded return typeof jQuery !== \"undefined\" && !jQuery.event.triggered ? jQuery.event.handle.apply( eventHandle.elem, arguments ) : undefined; }; } // Add elem as a property of the handle function // This is to prevent a memory leak with non-native events in IE. eventHandle.elem = elem; // Handle multiple events separated by a space // jQuery(...).bind(\"mouseover mouseout\", fn); types = types.split(\" \"); var type, i = 0, namespaces; while ( (type = types[ i++ ]) ) { handleObj = handleObjIn ? jQuery.extend({}, handleObjIn) : { handler: handler, data: data }; // Namespaced event handlers if ( type.indexOf(\".\") > -1 ) { namespaces = type.split(\".\"); type = namespaces.shift(); handleObj.namespace = namespaces.slice(0).sort().join(\".\"); } else { namespaces = []; handleObj.namespace = \"\"; } handleObj.type = type; handleObj.guid = handler.guid; // Get the current list of functions bound to this event var handlers = events[ type ], special = jQuery.event.special[ type ] || {}; // Init the event handler queue if ( !handlers ) { handlers = events[ type ] = []; // Check for a special event handler // Only use addEventListener/attachEvent if the special // events handler returns false if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) { // Bind the global event handler to the element if ( elem.addEventListener ) { elem.addEventListener( type, eventHandle, false ); } else if ( elem.attachEvent ) { elem.attachEvent( \"on\" + type, eventHandle ); } } } if ( special.add ) { special.add.call( elem, handleObj ); if ( !handleObj.handler.guid ) { handleObj.handler.guid = handler.guid; } } // Add the function to the element's handler list handlers.push( handleObj ); // Keep track of which events have been used, for global triggering jQuery.event.global[ type ] = true; } // Nullify elem to prevent memory leaks in IE elem = null; }, global: {}, // Detach an event or set of events from an element remove: function( elem, types, handler, pos ) { // don't do events on text and comment nodes if ( elem.nodeType === 3 || elem.nodeType === 8 ) { return; } var ret, type, fn, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType, elemData = jQuery.data( elem ), events = elemData && elemData.events; if ( !elemData || !events ) { return; } // types is actually an event object here if ( types && types.type ) { handler = types.handler; types = types.type; } // Unbind all events for the element if ( !types || typeof types === \"string\" && types.charAt(0) === \".\" ) { types = types || \"\"; for ( type in events ) { jQuery.event.remove( elem, type + types ); } return; } // Handle multiple events separated by a space // jQuery(...).unbind(\"mouseover mouseout\", fn); types = types.split(\" \"); while ( (type = types[ i++ ]) ) { origType = type; handleObj = null; all = type.indexOf(\".\") < 0; namespaces = []; if ( !all ) { // Namespaced event handlers namespaces = type.split(\".\"); type = namespaces.shift(); namespace = new RegExp(\"(^|\\\\.)\" + jQuery.map( namespaces.slice(0).sort(), fcleanup ).join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") } eventType = events[ type ]; if ( !eventType ) { continue; } if ( !handler ) { for ( var j = 0; j < eventType.length; j++ ) { handleObj = eventType[ j ]; if ( all || namespace.test( handleObj.namespace ) ) { jQuery.event.remove( elem, origType, handleObj.handler, j ); eventType.splice( j--, 1 ); } } continue; } special = jQuery.event.special[ type ] || {}; for ( var j = pos || 0; j < eventType.length; j++ ) { handleObj = eventType[ j ]; if ( handler.guid === handleObj.guid ) { // remove the given handler for the given type if ( all || namespace.test( handleObj.namespace ) ) { if ( pos == null ) { eventType.splice( j--, 1 ); } if ( special.remove ) { special.remove.call( elem, handleObj ); } } if ( pos != null ) { break; } } } // remove generic event handler if no more handlers exist if ( eventType.length === 0 || pos != null && eventType.length === 1 ) { if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) { removeEvent( elem, type, elemData.handle ); } ret = null; delete events[ type ]; } } // Remove the expando if it's no longer used if ( jQuery.isEmptyObject( events ) ) { var handle = elemData.handle; if ( handle ) { handle.elem = null; } delete elemData.events; delete elemData.handle; if ( jQuery.isEmptyObject( elemData ) ) { jQuery.removeData( elem ); } } }, // bubbling is internal trigger: function( event, data, elem /*, bubbling */ ) { // Event object or event type var type = event.type || event, bubbling = arguments[3]; if ( !bubbling ) { event = typeof event === \"object\" ? // jQuery.Event object event[expando] ? event : // Object literal jQuery.extend( jQuery.Event(type), event ) : // Just the event type (string) jQuery.Event(type); if ( type.indexOf(\"!\") >= 0 ) { event.type = type = type.slice(0, -1); event.exclusive = true; } // Handle a global trigger if ( !elem ) { // Don't bubble custom events when global (to avoid too much overhead) event.stopPropagation(); // Only trigger if we've ever bound an event for it if ( jQuery.event.global[ type ] ) { jQuery.each( jQuery.cache, function() { if ( this.events && this.events[type] ) { jQuery.event.trigger( event, data, this.handle.elem ); } }); } } // Handle triggering a single element // don't do events on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } // Clean up in case it is reused event.result = undefined; event.target = elem; // Clone the incoming data, if any data = jQuery.makeArray( data ); data.unshift( event ); } event.currentTarget = elem; // Trigger the event, it is assumed that \"handle\" is a function var handle = jQuery.data( elem, \"handle\" ); if ( handle ) { handle.apply( elem, data ); } var parent = elem.parentNode || elem.ownerDocument; // Trigger an inline bound script try { if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) { if ( elem[ \"on\" + type ] && elem[ \"on\" + type ].apply( elem, data ) === false ) { event.result = false; } } // prevent IE from throwing an error for some elements with some event types, see #3533 } catch (e) {} if ( !event.isPropagationStopped() && parent ) { jQuery.event.trigger( event, data, parent, true ); } else if ( !event.isDefaultPrevented() ) { var target = event.target, old, isClick = jQuery.nodeName(target, \"a\") && type === \"click\", special = jQuery.event.special[ type ] || {}; if ( (!special._default || special._default.call( elem, event ) === false) && !isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) { try { if ( target[ type ] ) { // Make sure that we don't accidentally re-trigger the onFOO events old = target[ \"on\" + type ]; if ( old ) { target[ \"on\" + type ] = null; } jQuery.event.triggered = true; target[ type ](); } // prevent IE from throwing an error for some elements with some event types, see #3533 } catch (e) {} if ( old ) { target[ \"on\" + type ] = old; } jQuery.event.triggered = false; } } }, handle: function( event ) { var all, handlers, namespaces, namespace, events; event = arguments[0] = jQuery.event.fix( event || window.event ); event.currentTarget = this; // Namespaced event handlers all = event.type.indexOf(\".\") < 0 && !event.exclusive; if ( !all ) { namespaces = event.type.split(\".\"); event.type = namespaces.shift(); namespace = new RegExp(\"(^|\\\\.)\" + namespaces.slice(0).sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\"); } var events = jQuery.data(this, \"events\"), handlers = events[ event.type ]; if ( events && handlers ) { // Clone the handlers to prevent manipulation handlers = handlers.slice(0); for ( var j = 0, l = handlers.length; j < l; j++ ) { var handleObj = handlers[ j ]; // Filter the functions by class if ( all || namespace.test( handleObj.namespace ) ) { // Pass in a reference to the handler function itself // So that we can later remove it event.handler = handleObj.handler; event.data = handleObj.data; event.handleObj = handleObj; var ret = handleObj.handler.apply( this, arguments ); if ( ret !== undefined ) { event.result = ret; if ( ret === false ) { event.preventDefault(); event.stopPropagation(); } } if ( event.isImmediatePropagationStopped() ) { break; } } } } return event.result; }, props: \"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"), fix: function( event ) { if ( event[ expando ] ) { return event; } // store a copy of the original event object // and \"clone\" to set read-only properties var originalEvent = event; event = jQuery.Event( originalEvent ); for ( var i = this.props.length, prop; i; ) { prop = this.props[ --i ]; event[ prop ] = originalEvent[ prop ]; } // Fix target property, if necessary if ( !event.target ) { event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either } // check if target is a textnode (safari) if ( event.target.nodeType === 3 ) { event.target = event.target.parentNode; } // Add relatedTarget, if necessary if ( !event.relatedTarget && event.fromElement ) { event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement; } // Calculate pageX/Y if missing and clientX/Y available if ( event.pageX == null && event.clientX != null ) { var doc = document.documentElement, body = document.body; event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0); event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0); } // Add which for key events if ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) ) { event.which = event.charCode || event.keyCode; } // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs) if ( !event.metaKey && event.ctrlKey ) { event.metaKey = event.ctrlKey; } // Add which for click: 1 === left; 2 === middle; 3 === right // Note: button is not normalized, so don't use it if ( !event.which && event.button !== undefined ) { event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) )); } return event; }, // Deprecated, use jQuery.guid instead guid: 1E8, // Deprecated, use jQuery.proxy instead proxy: jQuery.proxy, special: { ready: { // Make sure the ready event is setup setup: jQuery.bindReady, teardown: jQuery.noop }, live: { add: function( handleObj ) { jQuery.event.add( this, handleObj.origType, jQuery.extend({}, handleObj, {handler: liveHandler}) ); }, remove: function( handleObj ) { var remove = true, type = handleObj.origType.replace(rnamespaces, \"\"); jQuery.each( jQuery.data(this, \"events\").live || [], function() { if ( type === this.origType.replace(rnamespaces, \"\") ) { remove = false; return false; } }); if ( remove ) { jQuery.event.remove( this, handleObj.origType, liveHandler ); } } }, beforeunload: { setup: function( data, namespaces, eventHandle ) { // We only want to do this special case on windows if ( this.setInterval ) { this.onbeforeunload = eventHandle; } return false; }, teardown: function( namespaces, eventHandle ) { if ( this.onbeforeunload === eventHandle ) { this.onbeforeunload = null; } } } } }; var removeEvent = document.removeEventListener ? function( elem, type, handle ) { elem.removeEventListener( type, handle, false ); } : function( elem, type, handle ) { elem.detachEvent( \"on\" + type, handle ); }; jQuery.Event = function( src ) { // Allow instantiation without the 'new' keyword if ( !this.preventDefault ) { return new jQuery.Event( src ); } // Event object if ( src && src.type ) { this.originalEvent = src; this.type = src.type; // Event type } else { this.type = src; } // timeStamp is buggy for some events on Firefox(#3843) // So we won't rely on the native value this.timeStamp = now(); // Mark it as fixed this[ expando ] = true; }; function returnFalse() { return false; } function returnTrue() { return true; } // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html jQuery.Event.prototype = { preventDefault: function() { this.isDefaultPrevented = returnTrue; var e = this.originalEvent; if ( !e ) { return; } // if preventDefault exists run it on the original event if ( e.preventDefault ) { e.preventDefault(); } // otherwise set the returnValue property of the original event to false (IE) e.returnValue = false; }, stopPropagation: function() { this.isPropagationStopped = returnTrue; var e = this.originalEvent; if ( !e ) { return; } // if stopPropagation exists run it on the original event if ( e.stopPropagation ) { e.stopPropagation(); } // otherwise set the cancelBubble property of the original event to true (IE) e.cancelBubble = true; }, stopImmediatePropagation: function() { this.isImmediatePropagationStopped = returnTrue; this.stopPropagation(); }, isDefaultPrevented: returnFalse, isPropagationStopped: returnFalse, isImmediatePropagationStopped: returnFalse }; // Checks if an event happened on an element within another element // Used in jQuery.event.special.mouseenter and mouseleave handlers var withinElement = function( event ) { // Check if mouse(over|out) are still within the same parent element var parent = event.relatedTarget; // Firefox sometimes assigns relatedTarget a XUL element // which we cannot access the parentNode property of try { // Traverse up the tree while ( parent && parent !== this ) { parent = parent.parentNode; } if ( parent !== this ) { // set the correct event type event.type = event.data; // handle event if we actually just moused on to a non sub-element jQuery.event.handle.apply( this, arguments ); } // assuming we've left the element since we most likely mousedover a xul element } catch(e) { } }, // In case of event delegation, we only need to rename the event.type, // liveHandler will take care of the rest. delegate = function( event ) { event.type = event.data; jQuery.event.handle.apply( this, arguments ); }; // Create mouseenter and mouseleave events jQuery.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\" }, function( orig, fix ) { jQuery.event.special[ orig ] = { setup: function( data ) { jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig ); }, teardown: function( data ) { jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement ); } }; }); // submit delegation if ( !jQuery.support.submitBubbles ) { jQuery.event.special.submit = { setup: function( data, namespaces ) { if ( this.nodeName.toLowerCase() !== \"form\" ) { jQuery.event.add(this, \"click.specialSubmit\", function( e ) { var elem = e.target, type = elem.type; if ( (type === \"submit\" || type === \"image\") && jQuery( elem ).closest(\"form\").length ) { return trigger( \"submit\", this, arguments ); } }); jQuery.event.add(this, \"keypress.specialSubmit\", function( e ) { var elem = e.target, type = elem.type; if ( (type === \"text\" || type === \"password\") && jQuery( elem ).closest(\"form\").length && e.keyCode === 13 ) { return trigger( \"submit\", this, arguments ); } }); } else { return false; } }, teardown: function( namespaces ) { jQuery.event.remove( this, \".specialSubmit\" ); } }; } // change delegation, happens here so we have bind. if ( !jQuery.support.changeBubbles ) { var formElems = /textarea|input|select/i, changeFilters, getVal = function( elem ) { var type = elem.type, val = elem.value; if ( type === \"radio\" || type === \"checkbox\" ) { val = elem.checked; } else if ( type === \"select-multiple\" ) { val = elem.selectedIndex > -1 ? jQuery.map( elem.options, function( elem ) { return elem.selected; }).join(\"-\") : \"\"; } else if ( elem.nodeName.toLowerCase() === \"select\" ) { val = elem.selectedIndex; } return val; }, testChange = function testChange( e ) { var elem = e.target, data, val; if ( !formElems.test( elem.nodeName ) || elem.readOnly ) { return; } data = jQuery.data( elem, \"_change_data\" ); val = getVal(elem); // the current data will be also retrieved by beforeactivate if ( e.type !== \"focusout\" || elem.type !== \"radio\" ) { jQuery.data( elem, \"_change_data\", val ); } if ( data === undefined || val === data ) { return; } if ( data != null || val ) { e.type = \"change\"; return jQuery.event.trigger( e, arguments[1], elem ); } }; jQuery.event.special.change = { filters: { focusout: testChange, click: function( e ) { var elem = e.target, type = elem.type; if ( type === \"radio\" || type === \"checkbox\" || elem.nodeName.toLowerCase() === \"select\" ) { return testChange.call( this, e ); } }, // Change has to be called before submit // Keydown will be called before keypress, which is used in submit-event delegation keydown: function( e ) { var elem = e.target, type = elem.type; if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== \"textarea\") || (e.keyCode === 32 && (type === \"checkbox\" || type === \"radio\")) || type === \"select-multiple\" ) { return testChange.call( this, e ); } }, // Beforeactivate happens also before the previous element is blurred // with this event you can't trigger a change event, but you can store // information/focus[in] is not needed anymore beforeactivate: function( e ) { var elem = e.target; jQuery.data( elem, \"_change_data\", getVal(elem) ); } }, setup: function( data, namespaces ) { if ( this.type === \"file\" ) { return false; } for ( var type in changeFilters ) { jQuery.event.add( this, type + \".specialChange\", changeFilters[type] ); } return formElems.test( this.nodeName ); }, teardown: function( namespaces ) { jQuery.event.remove( this, \".specialChange\" ); return formElems.test( this.nodeName ); } }; changeFilters = jQuery.event.special.change.filters; } function trigger( type, elem, args ) { args[0].type = type; return jQuery.event.handle.apply( elem, args ); } // Create \"bubbling\" focus and blur events if ( document.addEventListener ) { jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) { jQuery.event.special[ fix ] = { setup: function() { this.addEventListener( orig, handler, true ); }, teardown: function() { this.removeEventListener( orig, handler, true ); } }; function handler( e ) { e = jQuery.event.fix( e ); e.type = fix; return jQuery.event.handle.call( this, e ); } }); } jQuery.each([\"bind\", \"one\"], function( i, name ) { jQuery.fn[ name ] = function( type, data, fn ) { // Handle object literals if ( typeof type === \"object\" ) { for ( var key in type ) { this[ name ](key, data, type[key], fn); } return this; } if ( jQuery.isFunction( data ) ) { fn = data; data = undefined; } var handler = name === \"one\" ? jQuery.proxy( fn, function( event ) { jQuery( this ).unbind( event, handler ); return fn.apply( this, arguments ); }) : fn; if ( type === \"unload\" && name !== \"one\" ) { this.one( type, data, fn ); } else { for ( var i = 0, l = this.length; i < l; i++ ) { jQuery.event.add( this[i], type, handler, data ); } } return this; }; }); jQuery.fn.extend({ unbind: function( type, fn ) { // Handle object literals if ( typeof type === \"object\" && !type.preventDefault ) { for ( var key in type ) { this.unbind(key, type[key]); } } else { for ( var i = 0, l = this.length; i < l; i++ ) { jQuery.event.remove( this[i], type, fn ); } } return this; }, delegate: function( selector, types, data, fn ) { return this.live( types, data, fn, selector ); }, undelegate: function( selector, types, fn ) { if ( arguments.length === 0 ) { return this.unbind( \"live\" ); } else { return this.die( types, null, fn, selector ); } }, trigger: function( type, data ) { return this.each(function() { jQuery.event.trigger( type, data, this ); }); }, triggerHandler: function( type, data ) { if ( this[0] ) { var event = jQuery.Event( type ); event.preventDefault(); event.stopPropagation(); jQuery.event.trigger( event, data, this[0] ); return event.result; } }, toggle: function( fn ) { // Save reference to arguments for access in closure var args = arguments, i = 1; // link all the functions, so any of them can unbind this click handler while ( i < args.length ) { jQuery.proxy( fn, args[ i++ ] ); } return this.click( jQuery.proxy( fn, function( event ) { // Figure out which function to execute var lastToggle = ( jQuery.data( this, \"lastToggle\" + fn.guid ) || 0 ) % i; jQuery.data( this, \"lastToggle\" + fn.guid, lastToggle + 1 ); // Make sure that clicks stop event.preventDefault(); // and execute the function return args[ lastToggle ].apply( this, arguments ) || false; })); }, hover: function( fnOver, fnOut ) { return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver ); } }); var liveMap = { focus: \"focusin\", blur: \"focusout\", mouseenter: \"mouseover\", mouseleave: \"mouseout\" }; jQuery.each([\"live\", \"die\"], function( i, name ) { jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) { var type, i = 0, match, namespaces, preType, selector = origSelector || this.selector, context = origSelector ? this : jQuery( this.context ); if ( jQuery.isFunction( data ) ) { fn = data; data = undefined; } types = (types || \"\").split(\" \"); while ( (type = types[ i++ ]) != null ) { match = rnamespaces.exec( type ); namespaces = \"\"; if ( match ) { namespaces = match[0]; type = type.replace( rnamespaces, \"\" ); } if ( type === \"hover\" ) { types.push( \"mouseenter\" + namespaces, \"mouseleave\" + namespaces ); continue; } preType = type; if ( type === \"focus\" || type === \"blur\" ) { types.push( liveMap[ type ] + namespaces ); type = type + namespaces; } else { type = (liveMap[ type ] || type) + namespaces; } if ( name === \"live\" ) { // bind live handler context.each(function(){ jQuery.event.add( this, liveConvert( type, selector ), { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } ); }); } else { // unbind live handler context.unbind( liveConvert( type, selector ), fn ); } } return this; } }); function liveHandler( event ) { var stop, elems = [], selectors = [], args = arguments, related, match, handleObj, elem, j, i, l, data, events = jQuery.data( this, \"events\" ); // Make sure we avoid non-left-click bubbling in Firefox (#3861) if ( event.liveFired === this || !events || !events.live || event.button && event.type === \"click\" ) { return; } event.liveFired = this; var live = events.live.slice(0); for ( j = 0; j < live.length; j++ ) { handleObj = live[j]; if ( handleObj.origType.replace( rnamespaces, \"\" ) === event.type ) { selectors.push( handleObj.selector ); } else { live.splice( j--, 1 ); } } match = jQuery( event.target ).closest( selectors, event.currentTarget ); for ( i = 0, l = match.length; i < l; i++ ) { for ( j = 0; j < live.length; j++ ) { handleObj = live[j]; if ( match[i].selector === handleObj.selector ) { elem = match[i].elem; related = null; // Those two events require additional checking if ( handleObj.preType === \"mouseenter\" || handleObj.preType === \"mouseleave\" ) { related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0]; } if ( !related || related !== elem ) { elems.push({ elem: elem, handleObj: handleObj }); } } } } for ( i = 0, l = elems.length; i < l; i++ ) { match = elems[i]; event.currentTarget = match.elem; event.data = match.handleObj.data; event.handleObj = match.handleObj; if ( match.handleObj.origHandler.apply( match.elem, args ) === false ) { stop = false; break; } } return stop; } function liveConvert( type, selector ) { return \"live.\" + (type && type !== \"*\" ? type + \".\" : \"\") + selector.replace(/\\./g, \"`\").replace(/ /g, \"&\"); } jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) { // Handle event binding jQuery.fn[ name ] = function( fn ) { return fn ? this.bind( name, fn ) : this.trigger( name ); }; if ( jQuery.attrFn ) { jQuery.attrFn[ name ] = true; } }); // Prevent memory leaks in IE // Window isn't included so as not to unbind existing unload events // More info: // - http://isaacschlueter.com/2006/10/msie-memory-leaks/ if ( window.attachEvent && !window.addEventListener ) { window.attachEvent(\"onunload\", function() { for ( var id in jQuery.cache ) { if ( jQuery.cache[ id ].handle ) { // Try/Catch is to handle iframes being unloaded, see #4280 try { jQuery.event.remove( jQuery.cache[ id ].handle.elem ); } catch(e) {} } } }); } /*! * Sizzle CSS Selector Engine - v1.0 * Copyright 2009, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * More information: http://sizzlejs.com/ */ (function(){ var chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g, done = 0, toString = Object.prototype.toString, hasDuplicate = false, baseHasDuplicate = true; // Here we check if the JavaScript engine is using some sort of // optimization where it does not always call our comparision // function. If that is the case, discard the hasDuplicate value. // Thus far that includes Google Chrome. [0, 0].sort(function(){ baseHasDuplicate = false; return 0; }); var Sizzle = function(selector, context, results, seed) { results = results || []; var origContext = context = context || document; if ( context.nodeType !== 1 && context.nodeType !== 9 ) { return []; } if ( !selector || typeof selector !== \"string\" ) { return results; } var parts = [], m, set, checkSet, extra, prune = true, contextXML = isXML(context), soFar = selector; // Reset the position of the chunker regexp (start from head) while ( (chunker.exec(\"\"), m = chunker.exec(soFar)) !== null ) { soFar = m[3]; parts.push( m[1] ); if ( m[2] ) { extra = m[3]; break; } } if ( parts.length > 1 && origPOS.exec( selector ) ) { if ( parts.length === 2 && Expr.relative[ parts[0] ] ) { set = posProcess( parts[0] + parts[1], context ); } else { set = Expr.relative[ parts[0] ] ? [ context ] : Sizzle( parts.shift(), context ); while ( parts.length ) { selector = parts.shift(); if ( Expr.relative[ selector ] ) { selector += parts.shift(); } set = posProcess( selector, set ); } } } else { // Take a shortcut and set the context if the root selector is an ID // (but not if it'll be faster if the inner selector is an ID) if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML && Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) { var ret = Sizzle.find( parts.shift(), context, contextXML ); context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0]; } if ( context ) { var ret = seed ? { expr: parts.pop(), set: makeArray(seed) } : Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML ); set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set; if ( parts.length > 0 ) { checkSet = makeArray(set); } else { prune = false; } while ( parts.length ) { var cur = parts.pop(), pop = cur; if ( !Expr.relative[ cur ] ) { cur = \"\"; } else { pop = parts.pop(); } if ( pop == null ) { pop = context; } Expr.relative[ cur ]( checkSet, pop, contextXML ); } } else { checkSet = parts = []; } } if ( !checkSet ) { checkSet = set; } if ( !checkSet ) { Sizzle.error( cur || selector ); } if ( toString.call(checkSet) === \"[object Array]\" ) { if ( !prune ) { results.push.apply( results, checkSet ); } else if ( context && context.nodeType === 1 ) { for ( var i = 0; checkSet[i] != null; i++ ) { if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) { results.push( set[i] ); } } } else { for ( var i = 0; checkSet[i] != null; i++ ) { if ( checkSet[i] && checkSet[i].nodeType === 1 ) { results.push( set[i] ); } } } } else { makeArray( checkSet, results ); } if ( extra ) { Sizzle( extra, origContext, results, seed ); Sizzle.uniqueSort( results ); } return results; }; Sizzle.uniqueSort = function(results){ if ( sortOrder ) { hasDuplicate = baseHasDuplicate; results.sort(sortOrder); if ( hasDuplicate ) { for ( var i = 1; i < results.length; i++ ) { if ( results[i] === results[i-1] ) { results.splice(i--, 1); } } } } return results; }; Sizzle.matches = function(expr, set){ return Sizzle(expr, null, null, set); }; Sizzle.find = function(expr, context, isXML){ var set, match; if ( !expr ) { return []; } for ( var i = 0, l = Expr.order.length; i < l; i++ ) { var type = Expr.order[i], match; if ( (match = Expr.leftMatch[ type ].exec( expr )) ) { var left = match[1]; match.splice(1,1); if ( left.substr( left.length - 1 ) !== \"\\\\\" ) { match[1] = (match[1] || \"\").replace(/\\\\/g, \"\"); set = Expr.find[ type ]( match, context, isXML ); if ( set != null ) { expr = expr.replace( Expr.match[ type ], \"\" ); break; } } } } if ( !set ) { set = context.getElementsByTagName(\"*\"); } return {set: set, expr: expr}; }; Sizzle.filter = function(expr, set, inplace, not){ var old = expr, result = [], curLoop = set, match, anyFound, isXMLFilter = set && set[0] && isXML(set[0]); while ( expr && set.length ) { for ( var type in Expr.filter ) { if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) { var filter = Expr.filter[ type ], found, item, left = match[1]; anyFound = false; match.splice(1,1); if ( left.substr( left.length - 1 ) === \"\\\\\" ) { continue; } if ( curLoop === result ) { result = []; } if ( Expr.preFilter[ type ] ) { match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter ); if ( !match ) { anyFound = found = true; } else if ( match === true ) { continue; } } if ( match ) { for ( var i = 0; (item = curLoop[i]) != null; i++ ) { if ( item ) { found = filter( item, match, i, curLoop ); var pass = not ^ !!found; if ( inplace && found != null ) { if ( pass ) { anyFound = true; } else { curLoop[i] = false; } } else if ( pass ) { result.push( item ); anyFound = true; } } } } if ( found !== undefined ) { if ( !inplace ) { curLoop = result; } expr = expr.replace( Expr.match[ type ], \"\" ); if ( !anyFound ) { return []; } break; } } } // Improper expression if ( expr === old ) { if ( anyFound == null ) { Sizzle.error( expr ); } else { break; } } old = expr; } return curLoop; }; Sizzle.error = function( msg ) { throw \"Syntax error, unrecognized expression: \" + msg; }; var Expr = Sizzle.selectors = { order: [ \"ID\", \"NAME\", \"TAG\" ], match: { ID: /#((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/, CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/, NAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)['\"]*\\]/, ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/, TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*-]|\\\\.)+)/, CHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/, POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/, PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/ }, leftMatch: {}, attrMap: { \"class\": \"className\", \"for\": \"htmlFor\" }, attrHandle: { href: function(elem){ return elem.getAttribute(\"href\"); } }, relative: { \"+\": function(checkSet, part){ var isPartStr = typeof part === \"string\", isTag = isPartStr && !/\\W/.test(part), isPartStrNotTag = isPartStr && !isTag; if ( isTag ) { part = part.toLowerCase(); } for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) { if ( (elem = checkSet[i]) ) { while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {} checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ? elem || false : elem === part; } } if ( isPartStrNotTag ) { Sizzle.filter( part, checkSet, true ); } }, \">\": function(checkSet, part){ var isPartStr = typeof part === \"string\"; if ( isPartStr && !/\\W/.test(part) ) { part = part.toLowerCase(); for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { var parent = elem.parentNode; checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false; } } } else { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { checkSet[i] = isPartStr ? elem.parentNode : elem.parentNode === part; } } if ( isPartStr ) { Sizzle.filter( part, checkSet, true ); } } }, \"\": function(checkSet, part, isXML){ var doneName = done++, checkFn = dirCheck; if ( typeof part === \"string\" && !/\\W/.test(part) ) { var nodeCheck = part = part.toLowerCase(); checkFn = dirNodeCheck; } checkFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML); }, \"~\": function(checkSet, part, isXML){ var doneName = done++, checkFn = dirCheck; if ( typeof part === \"string\" && !/\\W/.test(part) ) { var nodeCheck = part = part.toLowerCase(); checkFn = dirNodeCheck; } checkFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML); } }, find: { ID: function(match, context, isXML){ if ( typeof context.getElementById !== \"undefined\" && !isXML ) { var m = context.getElementById(match[1]); return m ? [m] : []; } }, NAME: function(match, context){ if ( typeof context.getElementsByName !== \"undefined\" ) { var ret = [], results = context.getElementsByName(match[1]); for ( var i = 0, l = results.length; i < l; i++ ) { if ( results[i].getAttribute(\"name\") === match[1] ) { ret.push( results[i] ); } } return ret.length === 0 ? null : ret; } }, TAG: function(match, context){ return context.getElementsByTagName(match[1]); } }, preFilter: { CLASS: function(match, curLoop, inplace, result, not, isXML){ match = \" \" + match[1].replace(/\\\\/g, \"\") + \" \"; if ( isXML ) { return match; } for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) { if ( elem ) { if ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n]/g, \" \").indexOf(match) >= 0) ) { if ( !inplace ) { result.push( elem ); } } else if ( inplace ) { curLoop[i] = false; } } } return false; }, ID: function(match){ return match[1].replace(/\\\\/g, \"\"); }, TAG: function(match, curLoop){ return match[1].toLowerCase(); }, CHILD: function(match){ if ( match[1] === \"nth\" ) { // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6' var test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec( match[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" || !/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]); // calculate the numbers (first)n+(last) including if they are negative match[2] = (test[1] + (test[2] || 1)) - 0; match[3] = test[3] - 0; } // TODO: Move to normal caching system match[0] = done++; return match; }, ATTR: function(match, curLoop, inplace, result, not, isXML){ var name = match[1].replace(/\\\\/g, \"\"); if ( !isXML && Expr.attrMap[name] ) { match[1] = Expr.attrMap[name]; } if ( match[2] === \"~=\" ) { match[4] = \" \" + match[4] + \" \"; } return match; }, PSEUDO: function(match, curLoop, inplace, result, not){ if ( match[1] === \"not\" ) { // If we're dealing with a complex expression, or a simple one if ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) { match[3] = Sizzle(match[3], null, null, curLoop); } else { var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not); if ( !inplace ) { result.push.apply( result, ret ); } return false; } } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) { return true; } return match; }, POS: function(match){ match.unshift( true ); return match; } }, filters: { enabled: function(elem){ return elem.disabled === false && elem.type !== \"hidden\"; }, disabled: function(elem){ return elem.disabled === true; }, checked: function(elem){ return elem.checked === true; }, selected: function(elem){ // Accessing this property makes selected-by-default // options in Safari work properly elem.parentNode.selectedIndex; return elem.selected === true; }, parent: function(elem){ return !!elem.firstChild; }, empty: function(elem){ return !elem.firstChild; }, has: function(elem, i, match){ return !!Sizzle( match[3], elem ).length; }, header: function(elem){ return /h\\d/i.test( elem.nodeName ); }, text: function(elem){ return \"text\" === elem.type; }, radio: function(elem){ return \"radio\" === elem.type; }, checkbox: function(elem){ return \"checkbox\" === elem.type; }, file: function(elem){ return \"file\" === elem.type; }, password: function(elem){ return \"password\" === elem.type; }, submit: function(elem){ return \"submit\" === elem.type; }, image: function(elem){ return \"image\" === elem.type; }, reset: function(elem){ return \"reset\" === elem.type; }, button: function(elem){ return \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\"; }, input: function(elem){ return /input|select|textarea|button/i.test(elem.nodeName); } }, setFilters: { first: function(elem, i){ return i === 0; }, last: function(elem, i, match, array){ return i === array.length - 1; }, even: function(elem, i){ return i % 2 === 0; }, odd: function(elem, i){ return i % 2 === 1; }, lt: function(elem, i, match){ return i < match[3] - 0; }, gt: function(elem, i, match){ return i > match[3] - 0; }, nth: function(elem, i, match){ return match[3] - 0 === i; }, eq: function(elem, i, match){ return match[3] - 0 === i; } }, filter: { PSEUDO: function(elem, match, i, array){ var name = match[1], filter = Expr.filters[ name ]; if ( filter ) { return filter( elem, i, match, array ); } else if ( name === \"contains\" ) { return (elem.textContent || elem.innerText || getText([ elem ]) || \"\").indexOf(match[3]) >= 0; } else if ( name === \"not\" ) { var not = match[3]; for ( var i = 0, l = not.length; i < l; i++ ) { if ( not[i] === elem ) { return false; } } return true; } else { Sizzle.error( \"Syntax error, unrecognized expression: \" + name ); } }, CHILD: function(elem, match){ var type = match[1], node = elem; switch (type) { case 'only': case 'first': while ( (node = node.previousSibling) ) { if ( node.nodeType === 1 ) { return false; } } if ( type === \"first\" ) { return true; } node = elem; case 'last': while ( (node = node.nextSibling) ) { if ( node.nodeType === 1 ) { return false; } } return true; case 'nth': var first = match[2], last = match[3]; if ( first === 1 && last === 0 ) { return true; } var doneName = match[0], parent = elem.parentNode; if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) { var count = 0; for ( node = parent.firstChild; node; node = node.nextSibling ) { if ( node.nodeType === 1 ) { node.nodeIndex = ++count; } } parent.sizcache = doneName; } var diff = elem.nodeIndex - last; if ( first === 0 ) { return diff === 0; } else { return ( diff % first === 0 && diff / first >= 0 ); } } }, ID: function(elem, match){ return elem.nodeType === 1 && elem.getAttribute(\"id\") === match; }, TAG: function(elem, match){ return (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match; }, CLASS: function(elem, match){ return (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \") .indexOf( match ) > -1; }, ATTR: function(elem, match){ var name = match[1], result = Expr.attrHandle[ name ] ? Expr.attrHandle[ name ]( elem ) : elem[ name ] != null ? elem[ name ] : elem.getAttribute( name ), value = result + \"\", type = match[2], check = match[4]; return result == null ? type === \"!=\" : type === \"=\" ? value === check : type === \"*=\" ? value.indexOf(check) >= 0 : type === \"~=\" ? (\" \" + value + \" \").indexOf(check) >= 0 : !check ? value && result !== false : type === \"!=\" ? value !== check : type === \"^=\" ? value.indexOf(check) === 0 : type === \"$=\" ? value.substr(value.length - check.length) === check : type === \"|=\" ? value === check || value.substr(0, check.length + 1) === check + \"-\" : false; }, POS: function(elem, match, i, array){ var name = match[2], filter = Expr.setFilters[ name ]; if ( filter ) { return filter( elem, i, match, array ); } } } }; var origPOS = Expr.match.POS; for ( var type in Expr.match ) { Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source ); Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, function(all, num){ return \"\\\\\" + (num - 0 + 1); })); } var makeArray = function(array, results) { array = Array.prototype.slice.call( array, 0 ); if ( results ) { results.push.apply( results, array ); return results; } return array; }; // Perform a simple check to determine if the browser is capable of // converting a NodeList to an array using builtin methods. // Also verifies that the returned array holds DOM nodes // (which is not the case in the Blackberry browser) try { Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType; // Provide a fallback method if it does not work } catch(e){ makeArray = function(array, results) { var ret = results || []; if ( toString.call(array) === \"[object Array]\" ) { Array.prototype.push.apply( ret, array ); } else { if ( typeof array.length === \"number\" ) { for ( var i = 0, l = array.length; i < l; i++ ) { ret.push( array[i] ); } } else { for ( var i = 0; array[i]; i++ ) { ret.push( array[i] ); } } } return ret; }; } var sortOrder; if ( document.documentElement.compareDocumentPosition ) { sortOrder = function( a, b ) { if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) { if ( a == b ) { hasDuplicate = true; } return a.compareDocumentPosition ? -1 : 1; } var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1; if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } else if ( \"sourceIndex\" in document.documentElement ) { sortOrder = function( a, b ) { if ( !a.sourceIndex || !b.sourceIndex ) { if ( a == b ) { hasDuplicate = true; } return a.sourceIndex ? -1 : 1; } var ret = a.sourceIndex - b.sourceIndex; if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } else if ( document.createRange ) { sortOrder = function( a, b ) { if ( !a.ownerDocument || !b.ownerDocument ) { if ( a == b ) { hasDuplicate = true; } return a.ownerDocument ? -1 : 1; } var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange(); aRange.setStart(a, 0); aRange.setEnd(a, 0); bRange.setStart(b, 0); bRange.setEnd(b, 0); var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange); if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } // Utility function for retreiving the text value of an array of DOM nodes function getText( elems ) { var ret = \"\", elem; for ( var i = 0; elems[i]; i++ ) { elem = elems[i]; // Get the text from text nodes and CDATA nodes if ( elem.nodeType === 3 || elem.nodeType === 4 ) { ret += elem.nodeValue; // Traverse everything else, except comment nodes } else if ( elem.nodeType !== 8 ) { ret += getText( elem.childNodes ); } } return ret; } // Check to see if the browser returns elements by name when // querying by getElementById (and provide a workaround) (function(){ // We're going to inject a fake input element with a specified name var form = document.createElement(\"div\"), id = \"script\" + (new Date).getTime(); form.innerHTML = \"\"; // Inject it into the root element, check its status, and remove it quickly var root = document.documentElement; root.insertBefore( form, root.firstChild ); // The workaround has to do additional checks after a getElementById // Which slows things down for other browsers (hence the branching) if ( document.getElementById( id ) ) { Expr.find.ID = function(match, context, isXML){ if ( typeof context.getElementById !== \"undefined\" && !isXML ) { var m = context.getElementById(match[1]); return m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : []; } }; Expr.filter.ID = function(elem, match){ var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\"); return elem.nodeType === 1 && node && node.nodeValue === match; }; } root.removeChild( form ); root = form = null; // release memory in IE })(); (function(){ // Check to see if the browser returns only elements // when doing getElementsByTagName(\"*\") // Create a fake element var div = document.createElement(\"div\"); div.appendChild( document.createComment(\"\") ); // Make sure no comments are found if ( div.getElementsByTagName(\"*\").length > 0 ) { Expr.find.TAG = function(match, context){ var results = context.getElementsByTagName(match[1]); // Filter out possible comments if ( match[1] === \"*\" ) { var tmp = []; for ( var i = 0; results[i]; i++ ) { if ( results[i].nodeType === 1 ) { tmp.push( results[i] ); } } results = tmp; } return results; }; } // Check to see if an attribute returns normalized href attributes div.innerHTML = \"\"; if ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" && div.firstChild.getAttribute(\"href\") !== \"#\" ) { Expr.attrHandle.href = function(elem){ return elem.getAttribute(\"href\", 2); }; } div = null; // release memory in IE })(); if ( document.querySelectorAll ) { (function(){ var oldSizzle = Sizzle, div = document.createElement(\"div\"); div.innerHTML = \"\"; // Safari can't handle uppercase or unicode characters when // in quirks mode. if ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) { return; } Sizzle = function(query, context, extra, seed){ context = context || document; // Only use querySelectorAll on non-XML documents // (ID selectors don't work in non-HTML documents) if ( !seed && context.nodeType === 9 && !isXML(context) ) { try { return makeArray( context.querySelectorAll(query), extra ); } catch(e){} } return oldSizzle(query, context, extra, seed); }; for ( var prop in oldSizzle ) { Sizzle[ prop ] = oldSizzle[ prop ]; } div = null; // release memory in IE })(); } (function(){ var div = document.createElement(\"div\"); div.innerHTML = \"\"; // Opera can't find a second classname (in 9.6) // Also, make sure that getElementsByClassName actually exists if ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) { return; } // Safari caches class attributes, doesn't catch changes (in 3.2) div.lastChild.className = \"e\"; if ( div.getElementsByClassName(\"e\").length === 1 ) { return; } Expr.order.splice(1, 0, \"CLASS\"); Expr.find.CLASS = function(match, context, isXML) { if ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) { return context.getElementsByClassName(match[1]); } }; div = null; // release memory in IE })(); function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { elem = elem[dir]; var match = false; while ( elem ) { if ( elem.sizcache === doneName ) { match = checkSet[elem.sizset]; break; } if ( elem.nodeType === 1 && !isXML ){ elem.sizcache = doneName; elem.sizset = i; } if ( elem.nodeName.toLowerCase() === cur ) { match = elem; break; } elem = elem[dir]; } checkSet[i] = match; } } } function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { elem = elem[dir]; var match = false; while ( elem ) { if ( elem.sizcache === doneName ) { match = checkSet[elem.sizset]; break; } if ( elem.nodeType === 1 ) { if ( !isXML ) { elem.sizcache = doneName; elem.sizset = i; } if ( typeof cur !== \"string\" ) { if ( elem === cur ) { match = true; break; } } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) { match = elem; break; } } elem = elem[dir]; } checkSet[i] = match; } } } var contains = document.compareDocumentPosition ? function(a, b){ return !!(a.compareDocumentPosition(b) & 16); } : function(a, b){ return a !== b && (a.contains ? a.contains(b) : true); }; var isXML = function(elem){ // documentElement is verified for cases where it doesn't yet exist // (such as loading iframes in IE - #4833) var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement; return documentElement ? documentElement.nodeName !== \"HTML\" : false; }; var posProcess = function(selector, context){ var tmpSet = [], later = \"\", match, root = context.nodeType ? [context] : context; // Position selectors must be done after the filter // And so must :not(positional) so we move all PSEUDOs to the end while ( (match = Expr.match.PSEUDO.exec( selector )) ) { later += match[0]; selector = selector.replace( Expr.match.PSEUDO, \"\" ); } selector = Expr.relative[selector] ? selector + \"*\" : selector; for ( var i = 0, l = root.length; i < l; i++ ) { Sizzle( selector, root[i], tmpSet ); } return Sizzle.filter( later, tmpSet ); }; // EXPOSE jQuery.find = Sizzle; jQuery.expr = Sizzle.selectors; jQuery.expr[\":\"] = jQuery.expr.filters; jQuery.unique = Sizzle.uniqueSort; jQuery.text = getText; jQuery.isXMLDoc = isXML; jQuery.contains = contains; return; window.Sizzle = Sizzle; })(); var runtil = /Until$/, rparentsprev = /^(?:parents|prevUntil|prevAll)/, // Note: This RegExp should be improved, or likely pulled from Sizzle rmultiselector = /,/, slice = Array.prototype.slice; // Implement the identical functionality for filter and not var winnow = function( elements, qualifier, keep ) { if ( jQuery.isFunction( qualifier ) ) { return jQuery.grep(elements, function( elem, i ) { return !!qualifier.call( elem, i, elem ) === keep; }); } else if ( qualifier.nodeType ) { return jQuery.grep(elements, function( elem, i ) { return (elem === qualifier) === keep; }); } else if ( typeof qualifier === \"string\" ) { var filtered = jQuery.grep(elements, function( elem ) { return elem.nodeType === 1; }); if ( isSimple.test( qualifier ) ) { return jQuery.filter(qualifier, filtered, !keep); } else { qualifier = jQuery.filter( qualifier, filtered ); } } return jQuery.grep(elements, function( elem, i ) { return (jQuery.inArray( elem, qualifier ) >= 0) === keep; }); }; jQuery.fn.extend({ find: function( selector ) { var ret = this.pushStack( \"\", \"find\", selector ), length = 0; for ( var i = 0, l = this.length; i < l; i++ ) { length = ret.length; jQuery.find( selector, this[i], ret ); if ( i > 0 ) { // Make sure that the results are unique for ( var n = length; n < ret.length; n++ ) { for ( var r = 0; r < length; r++ ) { if ( ret[r] === ret[n] ) { ret.splice(n--, 1); break; } } } } } return ret; }, has: function( target ) { var targets = jQuery( target ); return this.filter(function() { for ( var i = 0, l = targets.length; i < l; i++ ) { if ( jQuery.contains( this, targets[i] ) ) { return true; } } }); }, not: function( selector ) { return this.pushStack( winnow(this, selector, false), \"not\", selector); }, filter: function( selector ) { return this.pushStack( winnow(this, selector, true), \"filter\", selector ); }, is: function( selector ) { return !!selector && jQuery.filter( selector, this ).length > 0; }, closest: function( selectors, context ) { if ( jQuery.isArray( selectors ) ) { var ret = [], cur = this[0], match, matches = {}, selector; if ( cur && selectors.length ) { for ( var i = 0, l = selectors.length; i < l; i++ ) { selector = selectors[i]; if ( !matches[selector] ) { matches[selector] = jQuery.expr.match.POS.test( selector ) ? jQuery( selector, context || this.context ) : selector; } } while ( cur && cur.ownerDocument && cur !== context ) { for ( selector in matches ) { match = matches[selector]; if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) { ret.push({ selector: selector, elem: cur }); delete matches[selector]; } } cur = cur.parentNode; } } return ret; } var pos = jQuery.expr.match.POS.test( selectors ) ? jQuery( selectors, context || this.context ) : null; return this.map(function( i, cur ) { while ( cur && cur.ownerDocument && cur !== context ) { if ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selectors) ) { return cur; } cur = cur.parentNode; } return null; }); }, // Determine the position of an element within // the matched set of elements index: function( elem ) { if ( !elem || typeof elem === \"string\" ) { return jQuery.inArray( this[0], // If it receives a string, the selector is used // If it receives nothing, the siblings are used elem ? jQuery( elem ) : this.parent().children() ); } // Locate the position of the desired element return jQuery.inArray( // If it receives a jQuery object, the first element is used elem.jquery ? elem[0] : elem, this ); }, add: function( selector, context ) { var set = typeof selector === \"string\" ? jQuery( selector, context || this.context ) : jQuery.makeArray( selector ), all = jQuery.merge( this.get(), set ); return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ? all : jQuery.unique( all ) ); }, andSelf: function() { return this.add( this.prevObject ); } }); // A painfully simple check to see if an element is disconnected // from a document (should be improved, where feasible). function isDisconnected( node ) { return !node || !node.parentNode || node.parentNode.nodeType === 11; } jQuery.each({ parent: function( elem ) { var parent = elem.parentNode; return parent && parent.nodeType !== 11 ? parent : null; }, parents: function( elem ) { return jQuery.dir( elem, \"parentNode\" ); }, parentsUntil: function( elem, i, until ) { return jQuery.dir( elem, \"parentNode\", until ); }, next: function( elem ) { return jQuery.nth( elem, 2, \"nextSibling\" ); }, prev: function( elem ) { return jQuery.nth( elem, 2, \"previousSibling\" ); }, nextAll: function( elem ) { return jQuery.dir( elem, \"nextSibling\" ); }, prevAll: function( elem ) { return jQuery.dir( elem, \"previousSibling\" ); }, nextUntil: function( elem, i, until ) { return jQuery.dir( elem, \"nextSibling\", until ); }, prevUntil: function( elem, i, until ) { return jQuery.dir( elem, \"previousSibling\", until ); }, siblings: function( elem ) { return jQuery.sibling( elem.parentNode.firstChild, elem ); }, children: function( elem ) { return jQuery.sibling( elem.firstChild ); }, contents: function( elem ) { return jQuery.nodeName( elem, \"iframe\" ) ? elem.contentDocument || elem.contentWindow.document : jQuery.makeArray( elem.childNodes ); } }, function( name, fn ) { jQuery.fn[ name ] = function( until, selector ) { var ret = jQuery.map( this, fn, until ); if ( !runtil.test( name ) ) { selector = until; } if ( selector && typeof selector === \"string\" ) { ret = jQuery.filter( selector, ret ); } ret = this.length > 1 ? jQuery.unique( ret ) : ret; if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) { ret = ret.reverse(); } return this.pushStack( ret, name, slice.call(arguments).join(\",\") ); }; }); jQuery.extend({ filter: function( expr, elems, not ) { if ( not ) { expr = \":not(\" + expr + \")\"; } return jQuery.find.matches(expr, elems); }, dir: function( elem, dir, until ) { var matched = [], cur = elem[dir]; while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) { if ( cur.nodeType === 1 ) { matched.push( cur ); } cur = cur[dir]; } return matched; }, nth: function( cur, result, dir, elem ) { result = result || 1; var num = 0; for ( ; cur; cur = cur[dir] ) { if ( cur.nodeType === 1 && ++num === result ) { break; } } return cur; }, sibling: function( n, elem ) { var r = []; for ( ; n; n = n.nextSibling ) { if ( n.nodeType === 1 && n !== elem ) { r.push( n ); } } return r; } }); var rinlinejQuery = / jQuery\\d+=\"(?:\\d+|null)\"/g, rleadingWhitespace = /^\\s+/, rxhtmlTag = /(]*?)\\/>/g, rselfClosing = /^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i, rtagName = /\\s]+\\/)>/g, '=\"$1\">') .replace(rleadingWhitespace, \"\")], ownerDocument)[0]; } else { return this.cloneNode(true); } }); // Copy the events from the original to the clone if ( events === true ) { cloneCopyEvent( this, ret ); cloneCopyEvent( this.find(\"*\"), ret.find(\"*\") ); } // Return the cloned set return ret; }, html: function( value ) { if ( value === undefined ) { return this[0] && this[0].nodeType === 1 ? this[0].innerHTML.replace(rinlinejQuery, \"\") : null; // See if we can take a shortcut and just use innerHTML } else if ( typeof value === \"string\" && !rnocache.test( value ) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) && !wrapMap[ (rtagName.exec( value ) || [\"\", \"\"])[1].toLowerCase() ] ) { value = value.replace(rxhtmlTag, fcloseTag); try { for ( var i = 0, l = this.length; i < l; i++ ) { // Remove element nodes and prevent memory leaks if ( this[i].nodeType === 1 ) { jQuery.cleanData( this[i].getElementsByTagName(\"*\") ); this[i].innerHTML = value; } } // If using innerHTML throws an exception, use the fallback method } catch(e) { this.empty().append( value ); } } else if ( jQuery.isFunction( value ) ) { this.each(function(i){ var self = jQuery(this), old = self.html(); self.empty().append(function(){ return value.call( this, i, old ); }); }); } else { this.empty().append( value ); } return this; }, replaceWith: function( value ) { if ( this[0] && this[0].parentNode ) { // Make sure that the elements are removed from the DOM before they are inserted // this can help fix replacing a parent with child elements if ( jQuery.isFunction( value ) ) { return this.each(function(i) { var self = jQuery(this), old = self.html(); self.replaceWith( value.call( this, i, old ) ); }); } if ( typeof value !== \"string\" ) { value = jQuery(value).detach(); } return this.each(function() { var next = this.nextSibling, parent = this.parentNode; jQuery(this).remove(); if ( next ) { jQuery(next).before( value ); } else { jQuery(parent).append( value ); } }); } else { return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value ); } }, detach: function( selector ) { return this.remove( selector, true ); }, domManip: function( args, table, callback ) { var results, first, value = args[0], scripts = [], fragment, parent; // We can't cloneNode fragments that contain checked, in WebKit if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === \"string\" && rchecked.test( value ) ) { return this.each(function() { jQuery(this).domManip( args, table, callback, true ); }); } if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); args[0] = value.call(this, i, table ? self.html() : undefined); self.domManip( args, table, callback ); }); } if ( this[0] ) { parent = value && value.parentNode; // If we're in a fragment, just use that instead of building a new one if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) { results = { fragment: parent }; } else { results = buildFragment( args, this, scripts ); } fragment = results.fragment; if ( fragment.childNodes.length === 1 ) { first = fragment = fragment.firstChild; } else { first = fragment.firstChild; } if ( first ) { table = table && jQuery.nodeName( first, \"tr\" ); for ( var i = 0, l = this.length; i < l; i++ ) { callback.call( table ? root(this[i], first) : this[i], i > 0 || results.cacheable || this.length > 1 ? fragment.cloneNode(true) : fragment ); } } if ( scripts.length ) { jQuery.each( scripts, evalScript ); } } return this; function root( elem, cur ) { return jQuery.nodeName(elem, \"table\") ? (elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) : elem; } } }); function cloneCopyEvent(orig, ret) { var i = 0; ret.each(function() { if ( this.nodeName !== (orig[i] && orig[i].nodeName) ) { return; } var oldData = jQuery.data( orig[i++] ), curData = jQuery.data( this, oldData ), events = oldData && oldData.events; if ( events ) { delete curData.handle; curData.events = {}; for ( var type in events ) { for ( var handler in events[ type ] ) { jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data ); } } } }); } function buildFragment( args, nodes, scripts ) { var fragment, cacheable, cacheresults, doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document); // Only cache \"small\" (1/2 KB) strings that are associated with the main document // Cloning options loses the selected state, so don't cache them // IE 6 doesn't like it when you put or elements in a fragment // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache if ( args.length === 1 && typeof args[0] === \"string\" && args[0].length < 512 && doc === document && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) { cacheable = true; cacheresults = jQuery.fragments[ args[0] ]; if ( cacheresults ) { if ( cacheresults !== 1 ) { fragment = cacheresults; } } } if ( !fragment ) { fragment = doc.createDocumentFragment(); jQuery.clean( args, doc, fragment, scripts ); } if ( cacheable ) { jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1; } return { fragment: fragment, cacheable: cacheable }; } jQuery.fragments = {}; jQuery.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function( name, original ) { jQuery.fn[ name ] = function( selector ) { var ret = [], insert = jQuery( selector ), parent = this.length === 1 && this[0].parentNode; if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) { insert[ original ]( this[0] ); return this; } else { for ( var i = 0, l = insert.length; i < l; i++ ) { var elems = (i > 0 ? this.clone(true) : this).get(); jQuery.fn[ original ].apply( jQuery(insert[i]), elems ); ret = ret.concat( elems ); } return this.pushStack( ret, name, insert.selector ); } }; }); jQuery.extend({ clean: function( elems, context, fragment, scripts ) { context = context || document; // !context.createElement fails in IE with an error but returns typeof 'object' if ( typeof context.createElement === \"undefined\" ) { context = context.ownerDocument || context[0] && context[0].ownerDocument || document; } var ret = []; for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) { if ( typeof elem === \"number\" ) { elem += \"\"; } if ( !elem ) { continue; } // Convert html string into DOM nodes if ( typeof elem === \"string\" && !rhtml.test( elem ) ) { elem = context.createTextNode( elem ); } else if ( typeof elem === \"string\" ) { // Fix \"XHTML\"-style tags in all browsers elem = elem.replace(rxhtmlTag, fcloseTag); // Trim whitespace, otherwise indexOf won't work as expected var tag = (rtagName.exec( elem ) || [\"\", \"\"])[1].toLowerCase(), wrap = wrapMap[ tag ] || wrapMap._default, depth = wrap[0], div = context.createElement(\"div\"); // Go to html and back, then peel off extra wrappers div.innerHTML = wrap[1] + elem + wrap[2]; // Move to the right depth while ( depth-- ) { div = div.lastChild; } // Remove IE's autoinserted from table fragments if ( !jQuery.support.tbody ) { // String was a , *may* have spurious var hasBody = rtbody.test(elem), tbody = tag === \"table\" && !hasBody ? div.firstChild && div.firstChild.childNodes : // String was a bare or wrap[1] === \"\" && !hasBody ? div.childNodes : []; for ( var j = tbody.length - 1; j >= 0 ; --j ) { if ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) { tbody[ j ].parentNode.removeChild( tbody[ j ] ); } } } // IE completely kills leading whitespace when innerHTML is used if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) { div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild ); } elem = div.childNodes; } if ( elem.nodeType ) { ret.push( elem ); } else { ret = jQuery.merge( ret, elem ); } } if ( fragment ) { for ( var i = 0; ret[i]; i++ ) { if ( scripts && jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) { scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] ); } else { if ( ret[i].nodeType === 1 ) { ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName(\"script\"))) ); } fragment.appendChild( ret[i] ); } } } return ret; }, cleanData: function( elems ) { var data, id, cache = jQuery.cache, special = jQuery.event.special, deleteExpando = jQuery.support.deleteExpando; for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) { id = elem[ jQuery.expando ]; if ( id ) { data = cache[ id ]; if ( data.events ) { for ( var type in data.events ) { if ( special[ type ] ) { jQuery.event.remove( elem, type ); } else { removeEvent( elem, type, data.handle ); } } } if ( deleteExpando ) { delete elem[ jQuery.expando ]; } else if ( elem.removeAttribute ) { elem.removeAttribute( jQuery.expando ); } delete cache[ id ]; } } } }); // exclude the following css properties to add px var rexclude = /z-?index|font-?weight|opacity|zoom|line-?height/i, ralpha = /alpha\\([^)]*\\)/, ropacity = /opacity=([^)]*)/, rfloat = /float/i, rdashAlpha = /-([a-z])/ig, rupper = /([A-Z])/g, rnumpx = /^-?\\d+(?:px)?$/i, rnum = /^-?\\d/, cssShow = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, cssWidth = [ \"Left\", \"Right\" ], cssHeight = [ \"Top\", \"Bottom\" ], // cache check for defaultView.getComputedStyle getComputedStyle = document.defaultView && document.defaultView.getComputedStyle, // normalize float css property styleFloat = jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\", fcamelCase = function( all, letter ) { return letter.toUpperCase(); }; jQuery.fn.css = function( name, value ) { return access( this, name, value, true, function( elem, name, value ) { if ( value === undefined ) { return jQuery.curCSS( elem, name ); } if ( typeof value === \"number\" && !rexclude.test(name) ) { value += \"px\"; } jQuery.style( elem, name, value ); }); }; jQuery.extend({ style: function( elem, name, value ) { // don't set styles on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } // ignore negative width and height values #1599 if ( (name === \"width\" || name === \"height\") && parseFloat(value) < 0 ) { value = undefined; } var style = elem.style || elem, set = value !== undefined; // IE uses filters for opacity if ( !jQuery.support.opacity && name === \"opacity\" ) { if ( set ) { // IE has trouble with opacity if it does not have layout // Force it by setting the zoom level style.zoom = 1; // Set the alpha filter to set the opacity var opacity = parseInt( value, 10 ) + \"\" === \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\"; var filter = style.filter || jQuery.curCSS( elem, \"filter\" ) || \"\"; style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : opacity; } return style.filter && style.filter.indexOf(\"opacity=\") >= 0 ? (parseFloat( ropacity.exec(style.filter)[1] ) / 100) + \"\": \"\"; } // Make sure we're using the right name for getting the float value if ( rfloat.test( name ) ) { name = styleFloat; } name = name.replace(rdashAlpha, fcamelCase); if ( set ) { style[ name ] = value; } return style[ name ]; }, css: function( elem, name, force, extra ) { if ( name === \"width\" || name === \"height\" ) { var val, props = cssShow, which = name === \"width\" ? cssWidth : cssHeight; function getWH() { val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight; if ( extra === \"border\" ) { return; } jQuery.each( which, function() { if ( !extra ) { val -= parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0; } if ( extra === \"margin\" ) { val += parseFloat(jQuery.curCSS( elem, \"margin\" + this, true)) || 0; } else { val -= parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0; } }); } if ( elem.offsetWidth !== 0 ) { getWH(); } else { jQuery.swap( elem, props, getWH ); } return Math.max(0, Math.round(val)); } return jQuery.curCSS( elem, name, force ); }, curCSS: function( elem, name, force ) { var ret, style = elem.style, filter; // IE uses filters for opacity if ( !jQuery.support.opacity && name === \"opacity\" && elem.currentStyle ) { ret = ropacity.test(elem.currentStyle.filter || \"\") ? (parseFloat(RegExp.$1) / 100) + \"\" : \"\"; return ret === \"\" ? \"1\" : ret; } // Make sure we're using the right name for getting the float value if ( rfloat.test( name ) ) { name = styleFloat; } if ( !force && style && style[ name ] ) { ret = style[ name ]; } else if ( getComputedStyle ) { // Only \"float\" is needed here if ( rfloat.test( name ) ) { name = \"float\"; } name = name.replace( rupper, \"-$1\" ).toLowerCase(); var defaultView = elem.ownerDocument.defaultView; if ( !defaultView ) { return null; } var computedStyle = defaultView.getComputedStyle( elem, null ); if ( computedStyle ) { ret = computedStyle.getPropertyValue( name ); } // We should always get a number back from opacity if ( name === \"opacity\" && ret === \"\" ) { ret = \"1\"; } } else if ( elem.currentStyle ) { var camelCase = name.replace(rdashAlpha, fcamelCase); ret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ]; // From the awesome hack by Dean Edwards // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291 // If we're not dealing with a regular pixel number // but a number that has a weird ending, we need to convert it to pixels if ( !rnumpx.test( ret ) && rnum.test( ret ) ) { // Remember the original values var left = style.left, rsLeft = elem.runtimeStyle.left; // Put in the new values to get a computed value out elem.runtimeStyle.left = elem.currentStyle.left; style.left = camelCase === \"fontSize\" ? \"1em\" : (ret || 0); ret = style.pixelLeft + \"px\"; // Revert the changed values style.left = left; elem.runtimeStyle.left = rsLeft; } } return ret; }, // A method for quickly swapping in/out CSS properties to get correct calculations swap: function( elem, options, callback ) { var old = {}; // Remember the old values, and insert the new ones for ( var name in options ) { old[ name ] = elem.style[ name ]; elem.style[ name ] = options[ name ]; } callback.call( elem ); // Revert the old values for ( var name in options ) { elem.style[ name ] = old[ name ]; } } }); if ( jQuery.expr && jQuery.expr.filters ) { jQuery.expr.filters.hidden = function( elem ) { var width = elem.offsetWidth, height = elem.offsetHeight, skip = elem.nodeName.toLowerCase() === \"tr\"; return width === 0 && height === 0 && !skip ? true : width > 0 && height > 0 && !skip ? false : jQuery.curCSS(elem, \"display\") === \"none\"; }; jQuery.expr.filters.visible = function( elem ) { return !jQuery.expr.filters.hidden( elem ); }; } var jsc = now(), rscript = //gi, rselectTextarea = /select|textarea/i, rinput = /color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i, jsre = /=\\?(&|$)/, rquery = /\\?/, rts = /(\\?|&)_=.*?(&|$)/, rurl = /^(\\w+:)?\\/\\/([^\\/?#]+)/, r20 = /%20/g, // Keep a copy of the old load method _load = jQuery.fn.load; jQuery.fn.extend({ load: function( url, params, callback ) { if ( typeof url !== \"string\" ) { return _load.call( this, url ); // Don't do a request if no elements are being requested } else if ( !this.length ) { return this; } var off = url.indexOf(\" \"); if ( off >= 0 ) { var selector = url.slice(off, url.length); url = url.slice(0, off); } // Default to a GET request var type = \"GET\"; // If the second parameter was provided if ( params ) { // If it's a function if ( jQuery.isFunction( params ) ) { // We assume that it's the callback callback = params; params = null; // Otherwise, build a param string } else if ( typeof params === \"object\" ) { params = jQuery.param( params, jQuery.ajaxSettings.traditional ); type = \"POST\"; } } var self = this; // Request the remote document jQuery.ajax({ url: url, type: type, dataType: \"html\", data: params, complete: function( res, status ) { // If successful, inject the HTML into all the matched elements if ( status === \"success\" || status === \"notmodified\" ) { // See if a selector was specified self.html( selector ? // Create a dummy div to hold the results jQuery(\"\") // inject the contents of the document in, removing the scripts // to avoid any 'Permission Denied' errors in IE .append(res.responseText.replace(rscript, \"\")) // Locate the specified elements .find(selector) : // If not, just inject the full result res.responseText ); } if ( callback ) { self.each( callback, [res.responseText, status, res] ); } } }); return this; }, serialize: function() { return jQuery.param(this.serializeArray()); }, serializeArray: function() { return this.map(function() { return this.elements ? jQuery.makeArray(this.elements) : this; }) .filter(function() { return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type)); }) .map(function( i, elem ) { var val = jQuery(this).val(); return val == null ? null : jQuery.isArray(val) ? jQuery.map( val, function( val, i ) { return { name: elem.name, value: val }; }) : { name: elem.name, value: val }; }).get(); } }); // Attach a bunch of functions for handling common AJAX events jQuery.each( \"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function( i, o ) { jQuery.fn[o] = function( f ) { return this.bind(o, f); }; }); jQuery.extend({ get: function( url, data, callback, type ) { // shift arguments if data argument was omited if ( jQuery.isFunction( data ) ) { type = type || callback; callback = data; data = null; } return jQuery.ajax({ type: \"GET\", url: url, data: data, success: callback, dataType: type }); }, getScript: function( url, callback ) { return jQuery.get(url, null, callback, \"script\"); }, getJSON: function( url, data, callback ) { return jQuery.get(url, data, callback, \"json\"); }, post: function( url, data, callback, type ) { // shift arguments if data argument was omited if ( jQuery.isFunction( data ) ) { type = type || callback; callback = data; data = {}; } return jQuery.ajax({ type: \"POST\", url: url, data: data, success: callback, dataType: type }); }, ajaxSetup: function( settings ) { jQuery.extend( jQuery.ajaxSettings, settings ); }, ajaxSettings: { url: location.href, global: true, type: \"GET\", contentType: \"application/x-www-form-urlencoded\", processData: true, async: true, /* timeout: 0, data: null, username: null, password: null, traditional: false, */ // Create the request object; Microsoft failed to properly // implement the XMLHttpRequest in IE7 (can't request local files), // so we use the ActiveXObject when it is available // This function can be overriden by calling jQuery.ajaxSetup xhr: window.XMLHttpRequest && (window.location.protocol !== \"file:\" || !window.ActiveXObject) ? function() { return new window.XMLHttpRequest(); } : function() { try { return new window.ActiveXObject(\"Microsoft.XMLHTTP\"); } catch(e) {} }, accepts: { xml: \"application/xml, text/xml\", html: \"text/html\", script: \"text/javascript, application/javascript\", json: \"application/json, text/javascript\", text: \"text/plain\", _default: \"*/*\" } }, // Last-Modified header cache for next request lastModified: {}, etag: {}, ajax: function( origSettings ) { var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings); var jsonp, status, data, callbackContext = origSettings && origSettings.context || s, type = s.type.toUpperCase(); // convert data if not already a string if ( s.data && s.processData && typeof s.data !== \"string\" ) { s.data = jQuery.param( s.data, s.traditional ); } // Handle JSONP Parameter Callbacks if ( s.dataType === \"jsonp\" ) { if ( type === \"GET\" ) { if ( !jsre.test( s.url ) ) { s.url += (rquery.test( s.url ) ? \"&\" : \"?\") + (s.jsonp || \"callback\") + \"=?\"; } } else if ( !s.data || !jsre.test(s.data) ) { s.data = (s.data ? s.data + \"&\" : \"\") + (s.jsonp || \"callback\") + \"=?\"; } s.dataType = \"json\"; } // Build temporary JSONP function if ( s.dataType === \"json\" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) { jsonp = s.jsonpCallback || (\"jsonp\" + jsc++); // Replace the =? sequence both in the query string and the data if ( s.data ) { s.data = (s.data + \"\").replace(jsre, \"=\" + jsonp + \"$1\"); } s.url = s.url.replace(jsre, \"=\" + jsonp + \"$1\"); // We need to make sure // that a JSONP style response is executed properly s.dataType = \"script\"; // Handle JSONP-style loading window[ jsonp ] = window[ jsonp ] || function( tmp ) { data = tmp; success(); complete(); // Garbage collect window[ jsonp ] = undefined; try { delete window[ jsonp ]; } catch(e) {} if ( head ) { head.removeChild( script ); } }; } if ( s.dataType === \"script\" && s.cache === null ) { s.cache = false; } if ( s.cache === false && type === \"GET\" ) { var ts = now(); // try replacing _= if it is there var ret = s.url.replace(rts, \"$1_=\" + ts + \"$2\"); // if nothing was replaced, add timestamp to the end s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? \"&\" : \"?\") + \"_=\" + ts : \"\"); } // If data is available, append data to url for get requests if ( s.data && type === \"GET\" ) { s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.data; } // Watch for a new set of requests if ( s.global && ! jQuery.active++ ) { jQuery.event.trigger( \"ajaxStart\" ); } // Matches an absolute URL, and saves the domain var parts = rurl.exec( s.url ), remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host); // If we're requesting a remote document // and trying to load JSON or Script with a GET if ( s.dataType === \"script\" && type === \"GET\" && remote ) { var head = document.getElementsByTagName(\"head\")[0] || document.documentElement; var script = document.createElement(\"script\"); script.src = s.url; if ( s.scriptCharset ) { script.charset = s.scriptCharset; } // Handle Script loading if ( !jsonp ) { var done = false; // Attach handlers for all browsers script.onload = script.onreadystatechange = function() { if ( !done && (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\") ) { done = true; success(); complete(); // Handle memory leak in IE script.onload = script.onreadystatechange = null; if ( head && script.parentNode ) { head.removeChild( script ); } } }; } // Use insertBefore instead of appendChild to circumvent an IE6 bug. // This arises when a base node is used (#2709 and #4378). head.insertBefore( script, head.firstChild ); // We handle everything using the script element injection return undefined; } var requestDone = false; // Create the request object var xhr = s.xhr(); if ( !xhr ) { return; } // Open the socket // Passing null username, generates a login popup on Opera (#2865) if ( s.username ) { xhr.open(type, s.url, s.async, s.username, s.password); } else { xhr.open(type, s.url, s.async); } // Need an extra try/catch for cross domain requests in Firefox 3 try { // Set the correct header, if data is being sent if ( s.data || origSettings && origSettings.contentType ) { xhr.setRequestHeader(\"Content-Type\", s.contentType); } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. if ( s.ifModified ) { if ( jQuery.lastModified[s.url] ) { xhr.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[s.url]); } if ( jQuery.etag[s.url] ) { xhr.setRequestHeader(\"If-None-Match\", jQuery.etag[s.url]); } } // Set header so the called script knows that it's an XMLHttpRequest // Only send the header if it's not a remote XHR if ( !remote ) { xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"); } // Set the Accepts header for the server, depending on the dataType xhr.setRequestHeader(\"Accept\", s.dataType && s.accepts[ s.dataType ] ? s.accepts[ s.dataType ] + \", */*\" : s.accepts._default ); } catch(e) {} // Allow custom headers/mimetypes and early abort if ( s.beforeSend && s.beforeSend.call(callbackContext, xhr, s) === false ) { // Handle the global AJAX counter if ( s.global && ! --jQuery.active ) { jQuery.event.trigger( \"ajaxStop\" ); } // close opended socket xhr.abort(); return false; } if ( s.global ) { trigger(\"ajaxSend\", [xhr, s]); } // Wait for a response to come back var onreadystatechange = xhr.onreadystatechange = function( isTimeout ) { // The request was aborted if ( !xhr || xhr.readyState === 0 || isTimeout === \"abort\" ) { // Opera doesn't call onreadystatechange before this point // so we simulate the call if ( !requestDone ) { complete(); } requestDone = true; if ( xhr ) { xhr.onreadystatechange = jQuery.noop; } // The transfer is complete and the data is available, or the request timed out } else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === \"timeout\") ) { requestDone = true; xhr.onreadystatechange = jQuery.noop; status = isTimeout === \"timeout\" ? \"timeout\" : !jQuery.httpSuccess( xhr ) ? \"error\" : s.ifModified && jQuery.httpNotModified( xhr, s.url ) ? \"notmodified\" : \"success\"; var errMsg; if ( status === \"success\" ) { // Watch for, and catch, XML document parse errors try { // process the data (runs the xml through httpData regardless of callback) data = jQuery.httpData( xhr, s.dataType, s ); } catch(err) { status = \"parsererror\"; errMsg = err; } } // Make sure that the request was successful or notmodified if ( status === \"success\" || status === \"notmodified\" ) { // JSONP handles its own success callback if ( !jsonp ) { success(); } } else { jQuery.handleError(s, xhr, status, errMsg); } // Fire the complete handlers complete(); if ( isTimeout === \"timeout\" ) { xhr.abort(); } // Stop memory leaks if ( s.async ) { xhr = null; } } }; // Override the abort handler, if we can (IE doesn't allow it, but that's OK) // Opera doesn't fire onreadystatechange at all on abort try { var oldAbort = xhr.abort; xhr.abort = function() { if ( xhr ) { oldAbort.call( xhr ); } onreadystatechange( \"abort\" ); }; } catch(e) { } // Timeout checker if ( s.async && s.timeout > 0 ) { setTimeout(function() { // Check to see if the request is still happening if ( xhr && !requestDone ) { onreadystatechange( \"timeout\" ); } }, s.timeout); } // Send the data try { xhr.send( type === \"POST\" || type === \"PUT\" || type === \"DELETE\" ? s.data : null ); } catch(e) { jQuery.handleError(s, xhr, null, e); // Fire the complete handlers complete(); } // firefox 1.5 doesn't fire statechange for sync requests if ( !s.async ) { onreadystatechange(); } function success() { // If a local callback was specified, fire it and pass it the data if ( s.success ) { s.success.call( callbackContext, data, status, xhr ); } // Fire the global callback if ( s.global ) { trigger( \"ajaxSuccess\", [xhr, s] ); } } function complete() { // Process result if ( s.complete ) { s.complete.call( callbackContext, xhr, status); } // The request was completed if ( s.global ) { trigger( \"ajaxComplete\", [xhr, s] ); } // Handle the global AJAX counter if ( s.global && ! --jQuery.active ) { jQuery.event.trigger( \"ajaxStop\" ); } } function trigger(type, args) { (s.context ? jQuery(s.context) : jQuery.event).trigger(type, args); } // return XMLHttpRequest to allow aborting the request etc. return xhr; }, handleError: function( s, xhr, status, e ) { // If a local callback was specified, fire it if ( s.error ) { s.error.call( s.context || s, xhr, status, e ); } // Fire the global callback if ( s.global ) { (s.context ? jQuery(s.context) : jQuery.event).trigger( \"ajaxError\", [xhr, s, e] ); } }, // Counter for holding the number of active queries active: 0, // Determines if an XMLHttpRequest was successful or not httpSuccess: function( xhr ) { try { // IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450 return !xhr.status && location.protocol === \"file:\" || // Opera returns 0 when status is 304 ( xhr.status >= 200 && xhr.status < 300 ) || xhr.status === 304 || xhr.status === 1223 || xhr.status === 0; } catch(e) {} return false; }, // Determines if an XMLHttpRequest returns NotModified httpNotModified: function( xhr, url ) { var lastModified = xhr.getResponseHeader(\"Last-Modified\"), etag = xhr.getResponseHeader(\"Etag\"); if ( lastModified ) { jQuery.lastModified[url] = lastModified; } if ( etag ) { jQuery.etag[url] = etag; } // Opera returns 0 when status is 304 return xhr.status === 304 || xhr.status === 0; }, httpData: function( xhr, type, s ) { var ct = xhr.getResponseHeader(\"content-type\") || \"\", xml = type === \"xml\" || !type && ct.indexOf(\"xml\") >= 0, data = xml ? xhr.responseXML : xhr.responseText; if ( xml && data.documentElement.nodeName === \"parsererror\" ) { jQuery.error( \"parsererror\" ); } // Allow a pre-filtering function to sanitize the response // s is checked to keep backwards compatibility if ( s && s.dataFilter ) { data = s.dataFilter( data, type ); } // The filter can actually parse the response if ( typeof data === \"string\" ) { // Get the JavaScript object, if JSON is used. if ( type === \"json\" || !type && ct.indexOf(\"json\") >= 0 ) { data = jQuery.parseJSON( data ); // If the type is \"script\", eval it in global context } else if ( type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0 ) { jQuery.globalEval( data ); } } return data; }, // Serialize an array of form elements or a set of // key/values into a query string param: function( a, traditional ) { var s = []; // Set traditional to true for jQuery"}],"posts":[{"title":"Budget","slug":"Budget/Passage1","date":"2020-10-29T16:09:46.000Z","updated":"2020-10-29T20:00:52.310Z","comments":true,"path":"Budget/Passage1/","link":"","permalink":"https://knowledge.capitaltwo.ga/Budget/Passage1/","excerpt":"BUDGET A budget is an itemized summary of likely income and expenses for a given period of time. It’s a breakdown of the money you will bring in and what you plan to do with that money over the span of a day, week, month, semester, or year. Budgets can be made using a spreadsheet, online tool, or just a pen and a piece of paper. Regardless of what method you use or how much money you have to work with, a budget will help to keep you organized, give you a better idea of your financial situation, and allow you to feel more confident in the financial decisions you make.","text":"BUDGET A budget is an itemized summary of likely income and expenses for a given period of time. It’s a breakdown of the money you will bring in and what you plan to do with that money over the span of a day, week, month, semester, or year. Budgets can be made using a spreadsheet, online tool, or just a pen and a piece of paper. Regardless of what method you use or how much money you have to work with, a budget will help to keep you organized, give you a better idea of your financial situation, and allow you to feel more confident in the financial decisions you make. A budget helps you identify unnecessary expenditures, allows you to adapt quickly if your financial situation changes, and makes it more likely for you to achieve your financial goals. Step 1 The first step in creating a budget is to set your goals. What are your financial goals? Do you have debts you need to pay off? Do you want to minimize the debt you graduate with? Are you trying to save for a car, a vacation, or your future? Whatever your goals, make sure they are SMART. Specific: Write your goal so it’s clear and specific – &quot;I want to have enough in my savings account to cover &quot; Measurable : How much do you need? – Enough to cover repairs to my car, and other unexpected expenses, $1,000. Attainable: Break your goal down into bite-sized pieces, these are the steps you’ll take to reach the goal. — How much will you need to save each month to get to $1,000 within the time frame you have set for yourself? Relevant: You always want your goals to align with your values as well as the vision you have for your future. Be sure that the goals you are creating support what matters most to you. Time-bound: Your goals must have an end date. Having deadlines keeps you from putting it off until tomorrow.","categories":[{"name":"Budget","slug":"Budget","permalink":"https://knowledge.capitaltwo.ga/categories/Budget/"}],"tags":[{"name":"Budget knowledge","slug":"Budget-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Budget-knowledge/"}]},{"title":"Borrowing","slug":"Loan/Passage1","date":"2020-10-28T17:54:42.000Z","updated":"2020-10-29T20:00:26.966Z","comments":true,"path":"Loan/Passage1/","link":"","permalink":"https://knowledge.capitaltwo.ga/Loan/Passage1/","excerpt":"Borrowing Fundamentals Most students use federal loans to help finance their studies and some may turn to private loans. Taking out a loan is an important financial decision that can affect a student for years to come. It is critical for students to understand their loan options and associated responsibilities in order to make good borrowing decisions.","text":"Borrowing Fundamentals Most students use federal loans to help finance their studies and some may turn to private loans. Taking out a loan is an important financial decision that can affect a student for years to come. It is critical for students to understand their loan options and associated responsibilities in order to make good borrowing decisions. Before taking out a loan, students should be encouraged to use all available grants and scholarships since they do not need to be paid back. After accepting all grants and scholarships, students should consider if they are eligible to participate in the Federal Work-Study Program. Many work-study job opportunities are on or near campus and earnings from this program do not reduce eligibility for grants in the future. Students should consider the time commitment when working and weigh this with the need to focus on academic studies. Private Loans Private loans should be the last financing option to be considered and used. Private student loans are nonfederal loans made by a lender, such as a bank, credit union, state agency, or a school. They do not typically offer many of the benefits of federal student loans, such as fixed interest rates and income-based repayment plans. Borrowers of private loans also have fewer options for forbearance or deferment, and may have more difficulty getting back into good standing after default. Students should be encouraged to seek financial counseling before taking out private loans. Borrower Responsibilities and Options Whether using federal or private student loans, students should be aware of the details of their loan(s), as well as their responsibilities and options as borrowers. Some questions to ask are: Is it necessary to accept the full loan amount that is offered? When does the repayment period begin? Does interest accrue while the student is enrolled in school? How long is the repayment period? When will a loan be considered delinquent? If a loan becomes delinquent, when will it enter default? Can a defaulted loan be rehabilitated? What are the repayment options and when is it necessary to select one (e.g., at time of origination versus upon graduation)? What can be done to reduce debt burden (e.g., pay interest or a small amount of loan principal) while in school?","categories":[{"name":"Loan","slug":"Loan","permalink":"https://knowledge.capitaltwo.ga/categories/Loan/"}],"tags":[{"name":"Loan knowledge","slug":"Loan-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Loan-knowledge/"}]},{"title":"Introduction to Cryptocurrency","slug":"Cryptocurrency/Passage1","date":"2020-10-28T09:39:46.000Z","updated":"2020-10-29T20:00:37.790Z","comments":true,"path":"Cryptocurrency/Passage1/","link":"","permalink":"https://knowledge.capitaltwo.ga/Cryptocurrency/Passage1/","excerpt":"What is Cryptocurrency? A cryptocurrency is a digital or virtual currency that is secured by cryptography, which makes it nearly impossible to counterfeit or double-spend. Many cryptocurrencies are decentralized networks based on blockchain technology—a distributed ledger enforced by a disparate network of computers. A defining feature of cryptocurrencies is that they are generally not issued by any central authority, rendering them theoretically immune to government interference or manipulation.","text":"What is Cryptocurrency? A cryptocurrency is a digital or virtual currency that is secured by cryptography, which makes it nearly impossible to counterfeit or double-spend. Many cryptocurrencies are decentralized networks based on blockchain technology—a distributed ledger enforced by a disparate network of computers. A defining feature of cryptocurrencies is that they are generally not issued by any central authority, rendering them theoretically immune to government interference or manipulation. Cryptocurrencies are systems that allow for the secure payments online which are denominated in terms of virtual “tokens,” which are represented by ledger entries internal to the system. “Crypto” refers to the various encryption algorithms and cryptographic techniques that safeguard these entries, such as elliptical curve encryption, public-private key pairs, and hashing functions. Blockchain In banking, this is done with ledgers which track the flow of money through accounts. With cryptocurrency, the task is undertaken with blockchain using a form of math called cryptology. Blockchain is a secure record of every single transaction made using a cryptocurrency. Verified transactions are added to the blockchain as part of the mining process. Mining is therefore not just about creating new money but also validating transactions. While it’s possible to buy cryptocurrency- all you need is a digital wallet as part of a free app or a cryptocurrency tax software — finding places that will accept it, the variable transaction charges and volatile exchange rates make buying and selling with it difficult. Applications of Cryptocurrency Cryptocurrency could transform the way we do transactions. The so-called distributed ledger technology behind blockchain can be integrated into all sorts of business processes that require trust among multiple parties. That’s because blockchains store information that are both secure and transparent. Pretty exciting, but how is that possible? For one thing, because of the blocks themselves. Now, rather than a long string of records, information in a blockchain is cut up into sealed blocks. Thanks to the use of cryptography, it is impossible to change or counterfeit the records in the block. But what’s inside these blocks? Each block contains certain data, for example when selling an exclusive painting you want the block to have information on the name of the painting, the artist the previous owner, the new owner, the time of the sale and transaction. Next to the data, each block has an identifiable hash. This is a unique code, that functions like a fingerprint.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://knowledge.capitaltwo.ga/categories/Crypto/"}],"tags":[{"name":"Crypto knowledge","slug":"Crypto-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Crypto-knowledge/"}]},{"title":"Tell us who you interviewed","slug":"sample_withoutpoint","date":"2020-09-30T16:53:46.000Z","updated":"2020-10-15T20:59:29.217Z","comments":true,"path":"sample_withoutpoint/","link":"","permalink":"https://knowledge.capitaltwo.ga/sample_withoutpoint/","excerpt":"","text":"Without point means the first level of a topic, user are able to access this passage without showing any proof that they have finished previous sections.","categories":[{"name":"Development","slug":"Development","permalink":"https://knowledge.capitaltwo.ga/categories/Development/"}],"tags":[{"name":"Design","slug":"Design","permalink":"https://knowledge.capitaltwo.ga/tags/Design/"}]}],"categories":[{"name":"Budget","slug":"Budget","permalink":"https://knowledge.capitaltwo.ga/categories/Budget/"},{"name":"Loan","slug":"Loan","permalink":"https://knowledge.capitaltwo.ga/categories/Loan/"},{"name":"Crypto","slug":"Crypto","permalink":"https://knowledge.capitaltwo.ga/categories/Crypto/"},{"name":"Development","slug":"Development","permalink":"https://knowledge.capitaltwo.ga/categories/Development/"}],"tags":[{"name":"Budget knowledge","slug":"Budget-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Budget-knowledge/"},{"name":"Loan knowledge","slug":"Loan-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Loan-knowledge/"},{"name":"Crypto knowledge","slug":"Crypto-knowledge","permalink":"https://knowledge.capitaltwo.ga/tags/Crypto-knowledge/"},{"name":"Design","slug":"Design","permalink":"https://knowledge.capitaltwo.ga/tags/Design/"}]}